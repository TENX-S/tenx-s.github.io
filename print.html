<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>《Programming Rust》中文版</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">介绍</a></li><li class="chapter-item affix "><a href="preface.html">序言</a></li><li class="chapter-item "><a href="chapter_1/why_rust.html"><strong aria-hidden="true">1.</strong> 第一章 为什么用Rust？</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_1/type_safety.html"><strong aria-hidden="true">1.1.</strong> 类型安全</a></li></ol></li><li class="chapter-item "><a href="chapter_2/a_tour_of_rust.html"><strong aria-hidden="true">2.</strong> 第二章 一次Rust之旅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_2/downloading_and_installing_rust.html"><strong aria-hidden="true">2.1.</strong> 下载和安装Rust</a></li><li class="chapter-item "><a href="chapter_2/a_simple_function.html"><strong aria-hidden="true">2.2.</strong> 一个简单的函数</a></li><li class="chapter-item "><a href="chapter_2/writing_and_running_unit_tests.html"><strong aria-hidden="true">2.3.</strong> 编写并运行单元测试</a></li><li class="chapter-item "><a href="chapter_2/handling_command-line-arguments.html"><strong aria-hidden="true">2.4.</strong> 处理命令行参数</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/concurrency.html"><strong aria-hidden="true">2.5.</strong> 并发</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_2/Concurrency/what_the_mandelbrot_set_actually_is.html"><strong aria-hidden="true">2.5.1.</strong> 曼德勃罗集合的本质</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/parsing_pair_command-Line_arguments.html"><strong aria-hidden="true">2.5.2.</strong> 解析命令行参数</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/mapping_from_pixels_to_complex_numbers.html"><strong aria-hidden="true">2.5.3.</strong> 将像素映射为复数</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/plotting_the_set.html"><strong aria-hidden="true">2.5.4.</strong> 画出集合</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/writing_image_files.html"><strong aria-hidden="true">2.5.5.</strong> 写入图像文件</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/a_concurrent_mandelbrot_program.html"><strong aria-hidden="true">2.5.6.</strong> 一个并发的曼德勃罗程序</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/running_the_mandelbrot_plotter.html"><strong aria-hidden="true">2.5.7.</strong> 运行曼德勃罗绘图器</a></li><li class="chapter-item "><a href="chapter_2/Concurrency/safety_is_invisible.html"><strong aria-hidden="true">2.5.8.</strong> 隐藏的安全性</a></li></ol></li></ol></li><li class="chapter-item "><a href="chapter_3/basic_types.html"><strong aria-hidden="true">3.</strong> 第三章 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_3/MachineTypes/machine_types.html"><strong aria-hidden="true">3.1.</strong> 机器类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_3/MachineTypes/integer_types.html"><strong aria-hidden="true">3.1.1.</strong> 整数类型</a></li><li class="chapter-item "><a href="chapter_3/MachineTypes/floating-point_types.html"><strong aria-hidden="true">3.1.2.</strong> 浮点类型</a></li><li class="chapter-item "><a href="chapter_3/MachineTypes/the_bool_type.html"><strong aria-hidden="true">3.1.3.</strong> 布尔类型</a></li><li class="chapter-item "><a href="chapter_3/MachineTypes/characters.html"><strong aria-hidden="true">3.1.4.</strong> 字符类型</a></li></ol></li><li class="chapter-item "><a href="chapter_3/tuples.html"><strong aria-hidden="true">3.2.</strong> 元组</a></li><li class="chapter-item "><a href="chapter_3/PointerTypes/pointer_types.html"><strong aria-hidden="true">3.3.</strong> 指针类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_3/PointerTypes/references.html"><strong aria-hidden="true">3.3.1.</strong> 引用</a></li><li class="chapter-item "><a href="chapter_3/PointerTypes/boxes.html"><strong aria-hidden="true">3.3.2.</strong> 盒子</a></li><li class="chapter-item "><a href="chapter_3/PointerTypes/raw_pointers.html"><strong aria-hidden="true">3.3.3.</strong> 原生指针</a></li></ol></li><li class="chapter-item "><a href="chapter_3/ArraysVectorsAndSlices/array_vectors_and_slices.html"><strong aria-hidden="true">3.4.</strong> 数组，向量和切片</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_3/ArraysVectorsAndSlices/.md.html"><strong aria-hidden="true">3.4.1.</strong> 数组</a></li><li class="chapter-item "><a href="chapter_3/ArraysVectorsAndSlices/.md.html"><strong aria-hidden="true">3.4.2.</strong> 向量</a></li><li class="chapter-item "><a href="chapter_3/ArraysVectorsAndSlices/building_vectors_element_by_element.html"><strong aria-hidden="true">3.4.3.</strong> 一个元素一个元素地构造向量</a></li><li class="chapter-item "><a href="chapter_3/ArraysVectorsAndSlices/slices.html"><strong aria-hidden="true">3.4.4.</strong> 切片</a></li></ol></li><li class="chapter-item "><a href="chapter_3/StringTypes/string_types.html"><strong aria-hidden="true">3.5.</strong> 字符串类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_3/StringTypes/string_literals.html"><strong aria-hidden="true">3.5.1.</strong> 字符串字面量</a></li><li class="chapter-item "><a href="chapter_3/StringTypes/byte_strings.html"><strong aria-hidden="true">3.5.2.</strong> 字节字符串</a></li><li class="chapter-item "><a href="chapter_3/StringTypes/strings_in_memory.html"><strong aria-hidden="true">3.5.3.</strong> 内存中的字符串</a></li><li class="chapter-item "><a href="chapter_3/StringTypes/string.html"><strong aria-hidden="true">3.5.4.</strong> 字符串</a></li><li class="chapter-item "><a href="chapter_3/StringTypes/using_string.html"><strong aria-hidden="true">3.5.5.</strong> 使用字符串</a></li><li class="chapter-item "><a href="chapter_3/StringTypes/other_string-like_types.html"><strong aria-hidden="true">3.5.6.</strong> 其他像字符串的类型</a></li></ol></li><li class="chapter-item "><a href="chapter_3/beyond_the_basics.html"><strong aria-hidden="true">3.6.</strong> 基本类型之外</a></li></ol></li><li class="chapter-item "><a href="chapter_4/ownership.html"><strong aria-hidden="true">4.</strong> 第四章 所有权</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_4/ownership.html"><strong aria-hidden="true">4.1.</strong> 所有权</a></li><li class="chapter-item "><a href="chapter_4/Moves/moves.html"><strong aria-hidden="true">4.2.</strong> 移动</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_4/Moves/more_operations_that_move.html"><strong aria-hidden="true">4.2.1.</strong> 其他会引发移动的操作</a></li><li class="chapter-item "><a href="chapter_4/Moves/moves_and_control_flow.html"><strong aria-hidden="true">4.2.2.</strong> 移动和控制流</a></li><li class="chapter-item "><a href="chapter_4/Moves/moves_and_indexed_content.html"><strong aria-hidden="true">4.2.3.</strong> 移动和索引元素</a></li></ol></li><li class="chapter-item "><a href="chapter_4/copy_types_the_exception_to_moves.html"><strong aria-hidden="true">4.3.</strong> 复制类型：移动的例外</a></li><li class="chapter-item "><a href="chapter_4/Rc_and_Arc_shared_ownership.html"><strong aria-hidden="true">4.4.</strong> Rc和Arc：共享所有权</a></li></ol></li><li class="chapter-item "><a href="chapter_5/references.html"><strong aria-hidden="true">5.</strong> 第五章 引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/references_as_values.html"><strong aria-hidden="true">5.1.</strong> 引用作为值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/rust_references_versus_C++_references.html"><strong aria-hidden="true">5.1.1.</strong> 引用：Rust vs C++</a></li><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/assigning_references.html"><strong aria-hidden="true">5.1.2.</strong> 赋予引用</a></li><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/references_to_references.html"><strong aria-hidden="true">5.1.3.</strong> 引用的引用</a></li><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/comparing_references.html"><strong aria-hidden="true">5.1.4.</strong> 比较引用</a></li><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/references_are_never_null.html"><strong aria-hidden="true">5.1.5.</strong> 引用永远不会为空</a></li><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/borrowing_references_to_arbitrary_expressions.html"><strong aria-hidden="true">5.1.6.</strong> 借用任意表达式的引用</a></li><li class="chapter-item "><a href="chapter_5/ReferencesAsValues/references_to_slices_and_trait_objects.html"><strong aria-hidden="true">5.1.7.</strong> 切片和trait object的引用</a></li></ol></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/.md.html"><strong aria-hidden="true">5.2.</strong> 引用安全</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_5/ReferenceSafety/borrowing_a_local_variable.html"><strong aria-hidden="true">5.2.1.</strong> 借用一个当前作用域的变量</a></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/receiving_references_as_parameters.html"><strong aria-hidden="true">5.2.2.</strong> 接收作为引用的参数</a></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/passing_references_as_arguments.html"><strong aria-hidden="true">5.2.3.</strong> 传递作为引用的参数</a></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/returning_references.html"><strong aria-hidden="true">5.2.4.</strong> 返回引用</a></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/structs_containing_references.html"><strong aria-hidden="true">5.2.5.</strong> 包含引用的结构体</a></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/distinct_lifetime_parameters.html"><strong aria-hidden="true">5.2.6.</strong> 独立的生命周期参数</a></li><li class="chapter-item "><a href="chapter_5/ReferenceSafety/omitting_lifetime_parameters.html"><strong aria-hidden="true">5.2.7.</strong> 忽略生命周期参数</a></li></ol></li><li class="chapter-item "><a href="chapter_5/sharing_versus_mutation.html"><strong aria-hidden="true">5.3.</strong> 共享 vs 可变</a></li><li class="chapter-item "><a href="chapter_5/taking_arms_against_a_sea_of_objects.html"><strong aria-hidden="true">5.4.</strong> 从都是对象引用的苦海中挣脱</a></li></ol></li><li class="chapter-item "><a href="chapter_6/expressions.html"><strong aria-hidden="true">6.</strong> 第六章 表达式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_6/an_expression_language.html"><strong aria-hidden="true">6.1.</strong> 一个基于表达式的语言</a></li><li class="chapter-item "><a href="chapter_6/blocks_and_semicolons.html"><strong aria-hidden="true">6.2.</strong> 块和分号</a></li><li class="chapter-item "><a href="chapter_6/declarations.html"><strong aria-hidden="true">6.3.</strong> 声明</a></li><li class="chapter-item "><a href="chapter_6/IfAndMatch/if_and_match.html"><strong aria-hidden="true">6.4.</strong> if和match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_6/if_let.html"><strong aria-hidden="true">6.4.1.</strong> if let</a></li></ol></li><li class="chapter-item "><a href="chapter_6/loops.html"><strong aria-hidden="true">6.5.</strong> 循环</a></li><li class="chapter-item "><a href="chapter_6/return_expressions.html"><strong aria-hidden="true">6.6.</strong> return表达式</a></li><li class="chapter-item "><a href="chapter_6/why_rust_has_loop.html"><strong aria-hidden="true">6.7.</strong> 为什么rust有循环</a></li><li class="chapter-item "><a href="chapter_6/function_and_method_calls.html"><strong aria-hidden="true">6.8.</strong> 函数和方法调用</a></li><li class="chapter-item "><a href="chapter_6/field_and_elements.html"><strong aria-hidden="true">6.9.</strong> 字段和元素</a></li><li class="chapter-item "><a href="chapter_6/reference_operators.html"><strong aria-hidden="true">6.10.</strong> 引用操作符</a></li><li class="chapter-item "><a href="chapter_6/arithmetic_bitwise_comparison_and_logical_operators.html"><strong aria-hidden="true">6.11.</strong> 算术，位，比较和逻辑操作符</a></li><li class="chapter-item "><a href="chapter_6/assignment.html"><strong aria-hidden="true">6.12.</strong> 赋值</a></li><li class="chapter-item "><a href="chapter_6/type_casts.html"><strong aria-hidden="true">6.13.</strong> 类型转换</a></li><li class="chapter-item "><a href="chapter_6/closures.html"><strong aria-hidden="true">6.14.</strong> 闭包</a></li><li class="chapter-item "><a href="chapter_6/precedence_and_associativity.html"><strong aria-hidden="true">6.15.</strong> 优先级和结合性</a></li><li class="chapter-item "><a href="chapter_6/onward.html"><strong aria-hidden="true">6.16.</strong> 前瞻</a></li></ol></li><li class="chapter-item "><a href="chapter_7/error_handling.html"><strong aria-hidden="true">7.</strong> 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_7/Panic/panic.html"><strong aria-hidden="true">7.1.</strong> Panic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_7/Panic/unwinding.html"><strong aria-hidden="true">7.1.1.</strong> 栈展开</a></li><li class="chapter-item "><a href="chapter_7/Panic/aborting.html"><strong aria-hidden="true">7.1.2.</strong> 丢弃</a></li></ol></li><li class="chapter-item "><a href="chapter_7/Result/result.html"><strong aria-hidden="true">7.2.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_7/Result/catching_errors.html"><strong aria-hidden="true">7.2.1.</strong> 捕捉错误</a></li><li class="chapter-item "><a href="chapter_7/Result/result_type_aliases.html"><strong aria-hidden="true">7.2.2.</strong> result类型的别名</a></li><li class="chapter-item "><a href="chapter_7/Result/printing_errors.html"><strong aria-hidden="true">7.2.3.</strong> 打印错误</a></li><li class="chapter-item "><a href="chapter_7/Result/propagating_errors.html"><strong aria-hidden="true">7.2.4.</strong> 传递错误</a></li><li class="chapter-item "><a href="chapter_7/Result/working_with_multiple_error_types.html"><strong aria-hidden="true">7.2.5.</strong> 处理多种错误类型</a></li><li class="chapter-item "><a href="chapter_7/Result/dealing_with_Errors_that_“Can’t_Happen”.html"><strong aria-hidden="true">7.2.6.</strong> 处理“不能发生”的错误</a></li><li class="chapter-item "><a href="chapter_7/Result/ignoring_errors.html"><strong aria-hidden="true">7.2.7.</strong> 忽略错误</a></li><li class="chapter-item "><a href="chapter_7/Result/handling_errors_in_main().html"><strong aria-hidden="true">7.2.8.</strong> 处理main()中的错误</a></li><li class="chapter-item "><a href="chapter_7/Result/declaring_a_custom_error_type.html"><strong aria-hidden="true">7.2.9.</strong> 声明一个定制的错误类型</a></li><li class="chapter-item "><a href="chapter_7/Result/why_results.html"><strong aria-hidden="true">7.2.10.</strong> 为什么会有result？</a></li></ol></li></ol></li><li class="chapter-item "><a href="chapter_8/crates_and_modules.html"><strong aria-hidden="true">8.</strong> 第八章 Crates和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_8/Crates/crates.html"><strong aria-hidden="true">8.1.</strong> Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_8/Crates/build_profiles.html"><strong aria-hidden="true">8.1.1.</strong> 建立配置文件</a></li></ol></li><li class="chapter-item "><a href="chapter_8/Modules/modules.html"><strong aria-hidden="true">8.2.</strong> 模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_8/Modules/modules_in_separate_files.html"><strong aria-hidden="true">8.2.1.</strong> 在不同文件中的模块</a></li><li class="chapter-item "><a href="chapter_8/Modules/paths_and_imports.html"><strong aria-hidden="true">8.2.2.</strong> 路径和导入</a></li><li class="chapter-item "><a href="chapter_8/Modules/the_standard_prelude.html"><strong aria-hidden="true">8.2.3.</strong> 标准预加载库</a></li><li class="chapter-item "><a href="chapter_8/Modules/items_the_building_blocks_of_rust.html"><strong aria-hidden="true">8.2.4.</strong> 构成Rust的单元</a></li></ol></li><li class="chapter-item "><a href="chapter_8/turning_a_program_into_a_library.html"><strong aria-hidden="true">8.3.</strong> 将程序变为库</a></li><li class="chapter-item "><a href="chapter_8/the_srcbin_directory.html"><strong aria-hidden="true">8.4.</strong> src/bin目录</a></li><li class="chapter-item "><a href="chapter_8/attributes.html"><strong aria-hidden="true">8.5.</strong> 属性</a></li><li class="chapter-item "><a href="chapter_8/TestsAndDocumentation/tests_and_documentation.html"><strong aria-hidden="true">8.6.</strong> 测试和文档</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_8/TestsAndDocumentation/integration_tests.html"><strong aria-hidden="true">8.6.1.</strong> 内部测试</a></li><li class="chapter-item "><a href="chapter_8/TestsAndDocumentation/documentation.html"><strong aria-hidden="true">8.6.2.</strong> 文档</a></li><li class="chapter-item "><a href="chapter_8/TestsAndDocumentation/doc-tests.html"><strong aria-hidden="true">8.6.3.</strong> 文档中的测试</a></li></ol></li><li class="chapter-item "><a href="chapter_8/SpecifyingDependencies/specifying_dependencies.html"><strong aria-hidden="true">8.7.</strong> 指定依赖</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_8/SpecifyingDependencies/versions.html"><strong aria-hidden="true">8.7.1.</strong> 版本</a></li><li class="chapter-item "><a href="chapter_8/SpecifyingDependencies/Cargo.lock.html"><strong aria-hidden="true">8.7.2.</strong> Cargo.lock</a></li></ol></li><li class="chapter-item "><a href="chapter_8/publishing_crates_to_crates.io.html"><strong aria-hidden="true">8.8.</strong> 发布crates至crates.io</a></li><li class="chapter-item "><a href="chapter_8/workspaces.html"><strong aria-hidden="true">8.9.</strong> 工作空间</a></li><li class="chapter-item "><a href="chapter_8/more_nice_things.html"><strong aria-hidden="true">8.10.</strong> 其他有趣的事</a></li></ol></li><li class="chapter-item "><a href="chapter_9/structs.html"><strong aria-hidden="true">9.</strong> 第九章 结构体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_9/named-field_structs.html"><strong aria-hidden="true">9.1.</strong> 命名字段结构体</a></li><li class="chapter-item "><a href="chapter_9/tuple-like_structs.html"><strong aria-hidden="true">9.2.</strong> 类原则结构体</a></li><li class="chapter-item "><a href="chapter_9/unit-like_Structs.html"><strong aria-hidden="true">9.3.</strong> 单位结构体</a></li><li class="chapter-item "><a href="chapter_9/struct_layout.html"><strong aria-hidden="true">9.4.</strong> struct的内存布局</a></li><li class="chapter-item "><a href="chapter_9/defining_methods_with_impl.html"><strong aria-hidden="true">9.5.</strong> 用impl定义方法</a></li><li class="chapter-item "><a href="chapter_9/generic_structs.html"><strong aria-hidden="true">9.6.</strong> 泛型结构体</a></li><li class="chapter-item "><a href="chapter_9/structs_with_lifetime_parameters.html"><strong aria-hidden="true">9.7.</strong> 带生命周期参数的结构体</a></li><li class="chapter-item "><a href="chapter_9/deriving_common_traits_for_struct_types.html"><strong aria-hidden="true">9.8.</strong> 为结构体类型派生通用traits</a></li><li class="chapter-item "><a href="chapter_9/interior_mutability.html"><strong aria-hidden="true">9.9.</strong> 内在可变性</a></li></ol></li><li class="chapter-item "><a href="chapter_10/enums_and_patterns.html"><strong aria-hidden="true">10.</strong> 第十章 枚举和模式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_10/Enums/enums.html"><strong aria-hidden="true">10.1.</strong> 枚举</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_10/Enums/enums_with_data.html"><strong aria-hidden="true">10.1.1.</strong> 带有数据的枚举</a></li><li class="chapter-item "><a href="chapter_10/Enums/enums_in_memory.html"><strong aria-hidden="true">10.1.2.</strong> 枚举的内存布局</a></li><li class="chapter-item "><a href="chapter_10/Enums/rich_data_structures_using_enums.html"><strong aria-hidden="true">10.1.3.</strong> 在枚举中使用许多的数据结构</a></li><li class="chapter-item "><a href="chapter_10/Enums/generic_enums.html"><strong aria-hidden="true">10.1.4.</strong> 泛型枚举</a></li></ol></li><li class="chapter-item "><a href="chapter_10/Patterns/patterns.html"><strong aria-hidden="true">10.2.</strong> 模式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_10/Patterns/literals_variables_and_wildcards_in_patterns.html"><strong aria-hidden="true">10.2.1.</strong> 模式中的字面量，变量和通配符</a></li><li class="chapter-item "><a href="chapter_10/Patterns/tuple_and_struct_patterns.html"><strong aria-hidden="true">10.2.2.</strong> 元组和结构体模式</a></li><li class="chapter-item "><a href="chapter_10/Patterns/reference_patterns.html"><strong aria-hidden="true">10.2.3.</strong> 引用模式</a></li><li class="chapter-item "><a href="chapter_10/Patterns/matching_multiple_possibilities.html"><strong aria-hidden="true">10.2.4.</strong> 满足许多可能性</a></li><li class="chapter-item "><a href="chapter_10/Patterns/pattern_guards.html"><strong aria-hidden="true">10.2.5.</strong> 模式判断</a></li><li class="chapter-item "><a href="chapter_10/Patterns/@_patterns.html"><strong aria-hidden="true">10.2.6.</strong> @模式</a></li><li class="chapter-item "><a href="chapter_10/Patterns/where_patterns_are_allowed.html"><strong aria-hidden="true">10.2.7.</strong> 哪里可以使用模式</a></li><li class="chapter-item "><a href="chapter_10/Patterns/populating_a_binary_tree.html"><strong aria-hidden="true">10.2.8.</strong> 填充一个二叉树</a></li></ol></li><li class="chapter-item "><a href="chapter_10/the_big_picture.html"><strong aria-hidden="true">10.3.</strong> 伟大构想</a></li></ol></li><li class="chapter-item "><a href="chapter_11/traits_and_generics.html"><strong aria-hidden="true">11.</strong> 第十一章 traits和泛型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_11/UsingTraits/using_traits.html"><strong aria-hidden="true">11.1.</strong> 使用Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_11/UsingTraits/trait_objects.html"><strong aria-hidden="true">11.1.1.</strong> trait objects</a></li><li class="chapter-item "><a href="chapter_11/UsingTraits/trait_object_layout.html"><strong aria-hidden="true">11.1.2.</strong> trait object的内存布局</a></li><li class="chapter-item "><a href="chapter_11/UsingTraits/generic_functions.html"><strong aria-hidden="true">11.1.3.</strong> 泛型函数</a></li><li class="chapter-item "><a href="chapter_11/UsingTraits/which_to_use.html"><strong aria-hidden="true">11.1.4.</strong> 用哪一个？</a></li></ol></li><li class="chapter-item "><a href="chapter_11/DefiningAndImplementingTraits/defining_and_implementing_traits.html"><strong aria-hidden="true">11.2.</strong> 定义并实现trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_11/default_methods.html"><strong aria-hidden="true">11.2.1.</strong> 默认方法</a></li><li class="chapter-item "><a href="chapter_11/traits_and_other_people’s_types.html"><strong aria-hidden="true">11.2.2.</strong> traits和其他人的类型</a></li><li class="chapter-item "><a href="chapter_11/self_in_traits.html"><strong aria-hidden="true">11.2.3.</strong> traits中的self</a></li><li class="chapter-item "><a href="chapter_11/subtraits.html"><strong aria-hidden="true">11.2.4.</strong> 子trait</a></li><li class="chapter-item "><a href="chapter_11/static_methods.html"><strong aria-hidden="true">11.2.5.</strong> 静态方法</a></li></ol></li><li class="chapter-item "><a href="chapter_11/fully_qualified_method_calls.html"><strong aria-hidden="true">11.3.</strong> 完备的方法调用</a></li><li class="chapter-item "><a href="chapter_11/TraitsThatDefineRelationshipsBetweenTypes/traits_that_define_relationships_between_types.html"><strong aria-hidden="true">11.4.</strong> 在类型间定义关系的trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_11/TraitsThatDefineRelationshipsBetweenTypes/associated_types_or_how_iterators_work.html"><strong aria-hidden="true">11.4.1.</strong> 关联类型(iterator是怎么运行的)</a></li><li class="chapter-item "><a href="chapter_11/TraitsThatDefineRelationshipsBetweenTypes/generic_traits_or_how_operator_overloading_works.html"><strong aria-hidden="true">11.4.2.</strong> 泛型trait(操作符重载的机理)</a></li><li class="chapter-item "><a href="chapter_11/TraitsThatDefineRelationshipsBetweenTypes/buddy_traits_or_how_rand_random_works.html"><strong aria-hidden="true">11.4.3.</strong> 密友trait(rand::random()是怎么实现的)</a></li></ol></li><li class="chapter-item "><a href="chapter_11/reverse-engineering_bounds.html"><strong aria-hidden="true">11.5.</strong> 对绑定的逆向工程</a></li><li class="chapter-item "><a href="chapter_11/conclusion.html"><strong aria-hidden="true">11.6.</strong> 总结</a></li></ol></li><li class="chapter-item "><a href="chapter_12/operator_overloading.html"><strong aria-hidden="true">12.</strong> 第十二章 重载操作符</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_12/ArithmeticAndBitwiseOperators/arithmetic_and_bitwise_operators.html"><strong aria-hidden="true">12.1.</strong> 算术和位操作符</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_12/ArithmeticAndBitwiseOperators/unary_operators.html"><strong aria-hidden="true">12.1.1.</strong> 一元操作符</a></li><li class="chapter-item "><a href="chapter_12/ArithmeticAndBitwiseOperators/binary_operators.html"><strong aria-hidden="true">12.1.2.</strong> 二元操作符</a></li><li class="chapter-item "><a href="chapter_12/ArithmeticAndBitwiseOperators/compound_assignment_operators.html"><strong aria-hidden="true">12.1.3.</strong> 复合赋值操作符</a></li></ol></li><li class="chapter-item "><a href="chapter_12/equality_tests.html"><strong aria-hidden="true">12.2.</strong> 相等性测试</a></li><li class="chapter-item "><a href="chapter_12/ordered_comparisons.html"><strong aria-hidden="true">12.3.</strong> 有序比较</a></li><li class="chapter-item "><a href="chapter_12/index_and_indexMut.html"><strong aria-hidden="true">12.4.</strong> index和indexMut</a></li><li class="chapter-item "><a href="chapter_12/other_operators.html"><strong aria-hidden="true">12.5.</strong> 其他操作符</a></li></ol></li><li class="chapter-item "><a href="chapter_13/utility_traits.html"><strong aria-hidden="true">13.</strong> 第十三章 实用Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_13/drop.html"><strong aria-hidden="true">13.1.</strong> Drop</a></li><li class="chapter-item "><a href="chapter_13/sized.html"><strong aria-hidden="true">13.2.</strong> Sized</a></li><li class="chapter-item "><a href="chapter_13/clone.html"><strong aria-hidden="true">13.3.</strong> Clone</a></li><li class="chapter-item "><a href="chapter_13/copy.html"><strong aria-hidden="true">13.4.</strong> Copy</a></li><li class="chapter-item "><a href="chapter_13/deref_and_derefMut.html"><strong aria-hidden="true">13.5.</strong> Deref和derefMut</a></li><li class="chapter-item "><a href="chapter_13/default.html"><strong aria-hidden="true">13.6.</strong> Default</a></li><li class="chapter-item "><a href="chapter_13/asRef_and_asMut.html"><strong aria-hidden="true">13.7.</strong> AsRef和AsMut</a></li><li class="chapter-item "><a href="chapter_13/borrow_and_borrowMut.html"><strong aria-hidden="true">13.8.</strong> Borrow和BorrowMut</a></li><li class="chapter-item "><a href="chapter_13/from_and_into.html"><strong aria-hidden="true">13.9.</strong> From和Into</a></li><li class="chapter-item "><a href="chapter_13/toOwned.html"><strong aria-hidden="true">13.10.</strong> ToOwned</a></li><li class="chapter-item "><a href="chapter_13/borrow_and_toOwned_at_work_The_humble_cow.html"><strong aria-hidden="true">13.11.</strong> 使用Borrow和ToOwned：卑微的牛</a></li></ol></li><li class="chapter-item "><a href="chapter_14/clousures.html"><strong aria-hidden="true">14.</strong> 第十四章 闭包</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_14/CaptureVariables/capture_variables.html"><strong aria-hidden="true">14.1.</strong> 捕获变量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_14/CaptureVariables/closures_that_borrow.html"><strong aria-hidden="true">14.1.1.</strong> 借用的闭包</a></li><li class="chapter-item "><a href="chapter_14/CaptureVariables/closures_that_steal.html"><strong aria-hidden="true">14.1.2.</strong> 偷来的闭包</a></li></ol></li><li class="chapter-item "><a href="chapter_14/function_and_closure_types.html"><strong aria-hidden="true">14.2.</strong> 函数和闭包类型</a></li><li class="chapter-item "><a href="chapter_14/closure_performance.html"><strong aria-hidden="true">14.3.</strong> 闭包的性能</a></li><li class="chapter-item "><a href="chapter_14/ClosuresAndSafety/closures_and_safety.html"><strong aria-hidden="true">14.4.</strong> 闭包的安全性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_14/ClosuresAndSafety/closures_that_kill.html"><strong aria-hidden="true">14.4.1.</strong> 闭包丢弃的...</a></li><li class="chapter-item "><a href="chapter_14/ClosuresAndSafety/fnOnce.html"><strong aria-hidden="true">14.4.2.</strong> FnOnce</a></li><li class="chapter-item "><a href="chapter_14/ClosuresAndSafety/fnMut.html"><strong aria-hidden="true">14.4.3.</strong> FnMut</a></li></ol></li><li class="chapter-item "><a href="chapter_14/callbacks.html"><strong aria-hidden="true">14.5.</strong> 回调</a></li><li class="chapter-item "><a href="chapter_14/using_closures_effectively.html"><strong aria-hidden="true">14.6.</strong> 有效地使用闭包</a></li></ol></li><li class="chapter-item "><a href="chapter_15/iterators.html"><strong aria-hidden="true">15.</strong> 第十五章 迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_15/the_iterator_and_intoIterator_traits.html"><strong aria-hidden="true">15.1.</strong> 迭代器和其内置Traits</a></li><li class="chapter-item "><a href="chapter_15/CreatingIterators/creating_iterators.html"><strong aria-hidden="true">15.2.</strong> 创造迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_15/CreatingIterators/iter_and_iter_mut_methods.html"><strong aria-hidden="true">15.2.1.</strong> iter和iter_mut方法</a></li><li class="chapter-item "><a href="chapter_15/CreatingIterators/intoIterator_implementations.html"><strong aria-hidden="true">15.2.2.</strong> 内置迭代器的实现</a></li><li class="chapter-item "><a href="chapter_15/CreatingIterators/drain_Methods.html"><strong aria-hidden="true">15.2.3.</strong> drain方法</a></li><li class="chapter-item "><a href="chapter_15/CreatingIterators/other_iterator_sources.html"><strong aria-hidden="true">15.2.4.</strong> 其他迭代器的资料</a></li></ol></li><li class="chapter-item "><a href="chapter_15/IteratorAdapters/iterator_adapters.html"><strong aria-hidden="true">15.3.</strong> 迭代器的配备</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_15/map_and_filter.html"><strong aria-hidden="true">15.3.1.</strong> map和filter</a></li><li class="chapter-item "><a href="chapter_15/filter_map_and_flat_map.html"><strong aria-hidden="true">15.3.2.</strong> filter_map和flat_map</a></li><li class="chapter-item "><a href="chapter_15/scan.html"><strong aria-hidden="true">15.3.3.</strong> scan</a></li><li class="chapter-item "><a href="chapter_15/take_and_take_while.html"><strong aria-hidden="true">15.3.4.</strong> take和take_while</a></li><li class="chapter-item "><a href="chapter_15/skip_and_skip_while.html"><strong aria-hidden="true">15.3.5.</strong> skip和skip_while</a></li><li class="chapter-item "><a href="chapter_15/peekable.html"><strong aria-hidden="true">15.3.6.</strong> peekable</a></li><li class="chapter-item "><a href="chapter_15/fuse.html"><strong aria-hidden="true">15.3.7.</strong> fuse</a></li><li class="chapter-item "><a href="chapter_15/reversible_iterators_and_rev.html"><strong aria-hidden="true">15.3.8.</strong> 可逆的迭代器和rev</a></li><li class="chapter-item "><a href="chapter_15/inspect.html"><strong aria-hidden="true">15.3.9.</strong> inspect</a></li><li class="chapter-item "><a href="chapter_15/chain.html"><strong aria-hidden="true">15.3.10.</strong> chain</a></li><li class="chapter-item "><a href="chapter_15/enumerate.html"><strong aria-hidden="true">15.3.11.</strong> enumerate</a></li><li class="chapter-item "><a href="chapter_15/zip.html"><strong aria-hidden="true">15.3.12.</strong> zip</a></li><li class="chapter-item "><a href="chapter_15/by_ref.html"><strong aria-hidden="true">15.3.13.</strong> by_ref</a></li><li class="chapter-item "><a href="chapter_15/cloned.html"><strong aria-hidden="true">15.3.14.</strong> cloned</a></li><li class="chapter-item "><a href="chapter_15/cycle.html"><strong aria-hidden="true">15.3.15.</strong> cycle</a></li></ol></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/consuming_iterators.html"><strong aria-hidden="true">15.4.</strong> 消耗迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_15/ConsumingIterators/simple_accumulation_count_sum_product.html"><strong aria-hidden="true">15.4.1.</strong> 简单的累运算:计数，总和，乘积</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/max_min.html"><strong aria-hidden="true">15.4.2.</strong> max, min</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/max_by_min_by.html"><strong aria-hidden="true">15.4.3.</strong> max_by, min_by</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/max_by_key_min_by_key.html"><strong aria-hidden="true">15.4.4.</strong> max_by_key, min_by_key</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/comparing_item_sequences.html"><strong aria-hidden="true">15.4.5.</strong> 比较序列</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/any_and_all.html"><strong aria-hidden="true">15.4.6.</strong> any和all</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/position_rposition_and_exactSizeIterator.html"><strong aria-hidden="true">15.4.7.</strong> position, rposition, 和 ExactSizeIterator</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/fold.html"><strong aria-hidden="true">15.4.8.</strong> fold</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/nth.html"><strong aria-hidden="true">15.4.9.</strong> nth</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/last.html"><strong aria-hidden="true">15.4.10.</strong> last</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/find.html"><strong aria-hidden="true">15.4.11.</strong> find</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/building_collections_collect_and_fromIterator.html"><strong aria-hidden="true">15.4.12.</strong> 构建集合:collect和FromIterator</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/the_extend_trait.html"><strong aria-hidden="true">15.4.13.</strong> trait: extend</a></li><li class="chapter-item "><a href="chapter_15/ConsumingIterators/partition.html"><strong aria-hidden="true">15.4.14.</strong> partition</a></li></ol></li><li class="chapter-item "><a href="chapter_15/implementing_your_own_iterators.html"><strong aria-hidden="true">15.5.</strong> 实现你自己的迭代器</a></li></ol></li><li class="chapter-item "><a href="chapter_16/collections.html"><strong aria-hidden="true">16.</strong> 第十六章 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_16/overview.html"><strong aria-hidden="true">16.1.</strong> 总览</a></li><li class="chapter-item "><a href="chapter_16/Vec/vec.html"><strong aria-hidden="true">16.2.</strong> Vec</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_16/Vec/accessing_elements.html"><strong aria-hidden="true">16.2.1.</strong> 索引元素</a></li><li class="chapter-item "><a href="chapter_16/Vec/iteration.html"><strong aria-hidden="true">16.2.2.</strong> 迭代</a></li><li class="chapter-item "><a href="chapter_16/Vec/growing_and_shrinking_vectors.html"><strong aria-hidden="true">16.2.3.</strong> 增长和缩短的向量</a></li><li class="chapter-item "><a href="chapter_16/Vec/joining.html"><strong aria-hidden="true">16.2.4.</strong> 拼接</a></li><li class="chapter-item "><a href="chapter_16/Vec/splitting.html"><strong aria-hidden="true">16.2.5.</strong> 分割</a></li><li class="chapter-item "><a href="chapter_16/Vec/swapping.html"><strong aria-hidden="true">16.2.6.</strong> 交换</a></li><li class="chapter-item "><a href="chapter_16/Vec/sorting_and_searching.html"><strong aria-hidden="true">16.2.7.</strong> 排序和寻找</a></li><li class="chapter-item "><a href="chapter_16/Vec/comparing_slices.html"><strong aria-hidden="true">16.2.8.</strong> 比较切片</a></li><li class="chapter-item "><a href="chapter_16/Vec/random_elements.html"><strong aria-hidden="true">16.2.9.</strong> 随机元素</a></li><li class="chapter-item "><a href="chapter_16/Vec/rust_rules_out_invalidation_errors.html"><strong aria-hidden="true">16.2.10.</strong> Rust排除了无效错误</a></li></ol></li><li class="chapter-item "><a href="chapter_16/VecDeque.html"><strong aria-hidden="true">16.3.</strong> VecDeque</a></li><li class="chapter-item "><a href="chapter_16/LinkedList.html"><strong aria-hidden="true">16.4.</strong> LinkedList</a></li><li class="chapter-item "><a href="chapter_16/BinaryHeap.html"><strong aria-hidden="true">16.5.</strong> BinaryHeap</a></li><li class="chapter-item "><a href="chapter_16/HashMapAndBTreeMap/hashmap_and_btreemap.html"><strong aria-hidden="true">16.6.</strong> HashMap&lt;K,V&gt;和BTreeMap&lt;K,V&gt;</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_16/HashMapAndBTreeMap/entries.html"><strong aria-hidden="true">16.6.1.</strong> 条目</a></li><li class="chapter-item "><a href="chapter_16/HashMapAndBTreeMap/map_iteration.html"><strong aria-hidden="true">16.6.2.</strong> 映射迭代</a></li></ol></li><li class="chapter-item "><a href="chapter_16/HashSetAndBTreeSet/hashset_and_btreeset.html"><strong aria-hidden="true">16.7.</strong> HashSet和BTreeSet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_16/HashSetAndBTreeSet/set_iteration.html"><strong aria-hidden="true">16.7.1.</strong> 设置迭代</a></li><li class="chapter-item "><a href="chapter_16/HashSetAndBTreeSet/when_equal_values_are_different.html"><strong aria-hidden="true">16.7.2.</strong> 当相等的元素不一样时</a></li><li class="chapter-item "><a href="chapter_16/HashSetAndBTreeSet/whole-Set_operations.html"><strong aria-hidden="true">16.7.3.</strong> 整体操作</a></li></ol></li><li class="chapter-item "><a href="chapter_16/Hashing/hashing.html"><strong aria-hidden="true">16.8.</strong> 哈希</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_16/using_a_custom_hashing_algorithm.html"><strong aria-hidden="true">16.8.1.</strong> 使用定制的哈希算法</a></li></ol></li><li class="chapter-item "><a href="chapter_16/beyond_the_standard_collections.html"><strong aria-hidden="true">16.9.</strong> 标准集合之外</a></li></ol></li><li class="chapter-item "><a href="chapter_17/strings_and_text.html"><strong aria-hidden="true">17.</strong> 第十七章 字符串和文本</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/SomeUnicodeBackground/some_unicode_background.html"><strong aria-hidden="true">17.1.</strong> 一些Unicode背景知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/SomeUnicodeBackground/ascii_latin-1_and_unicode.html"><strong aria-hidden="true">17.1.1.</strong> ASCII，Latin-1和Unicode</a></li><li class="chapter-item "><a href="chapter_17/SomeUnicodeBackground/utf-8.html"><strong aria-hidden="true">17.1.2.</strong> UTF-8</a></li><li class="chapter-item "><a href="chapter_17/SomeUnicodeBackground/text_directionality.html"><strong aria-hidden="true">17.1.3.</strong> 定向文本</a></li></ol></li><li class="chapter-item "><a href="chapter_17/Characters(char)/char.html"><strong aria-hidden="true">17.2.</strong> 字符</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/Characters(char)/classifying_characters.html"><strong aria-hidden="true">17.2.1.</strong> 字符分类</a></li><li class="chapter-item "><a href="chapter_17/Characters(char)/handling_digits.html"><strong aria-hidden="true">17.2.2.</strong> 处理数字</a></li><li class="chapter-item "><a href="chapter_17/Characters(char)/case_conversion_for_characters.html"><strong aria-hidden="true">17.2.3.</strong> 字符的大小写转换</a></li><li class="chapter-item "><a href="chapter_17/Characters(char)/conversions_to_and_from_integers.html"><strong aria-hidden="true">17.2.4.</strong> 从整数转换和转换为整数</a></li></ol></li><li class="chapter-item "><a href="chapter_17/StringAndstr/String_and_str.html"><strong aria-hidden="true">17.3.</strong> String和str</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/StringAndstr/creating_string_values.html"><strong aria-hidden="true">17.3.1.</strong> 创造String的值</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/simple_inspection.html"><strong aria-hidden="true">17.3.2.</strong> 简单的反射</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/appending_and_inserting_text.html"><strong aria-hidden="true">17.3.3.</strong> 添加或插入文本</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/removing_text.html"><strong aria-hidden="true">17.3.4.</strong> 删除文本</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/conventions_for_searching_and_iterating.html"><strong aria-hidden="true">17.3.5.</strong> 搜索和迭代的惯例</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/patterns_for_searching_text.html"><strong aria-hidden="true">17.3.6.</strong> 搜索文本的模式</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/searching_and_replacing.html"><strong aria-hidden="true">17.3.7.</strong> 查找和替换</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/iterating_over_text.html"><strong aria-hidden="true">17.3.8.</strong> 遍历文本</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/trimming.html"><strong aria-hidden="true">17.3.9.</strong> 修剪</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/case_conversion_for_strings.html"><strong aria-hidden="true">17.3.10.</strong> 字符串的大小转换</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/parsing_other_types_from_strings.html"><strong aria-hidden="true">17.3.11.</strong> 将string解析为其他类型</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/converting_other_types_to_strings.html"><strong aria-hidden="true">17.3.12.</strong> 将其他类型转为string</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/borrowing_as_other_text-like_types.html"><strong aria-hidden="true">17.3.13.</strong> 像其他类文本一样的类型进行借用</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/accessing_text_as_utf-8.html"><strong aria-hidden="true">17.3.14.</strong> 访问utf-8的文本</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/producing_text_from_utf-8_data.html"><strong aria-hidden="true">17.3.15.</strong> 根据utf-8数据提供文本</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/putting_off_allocation.html"><strong aria-hidden="true">17.3.16.</strong> 推迟分配</a></li><li class="chapter-item "><a href="chapter_17/StringAndstr/strings_as_generic_collections.html"><strong aria-hidden="true">17.3.17.</strong> 作为泛型集合的字符串</a></li></ol></li><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_values.html"><strong aria-hidden="true">17.4.</strong> 格式化</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_text_values.html"><strong aria-hidden="true">17.4.1.</strong> 格式化文本值</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_numbers.html"><strong aria-hidden="true">17.4.2.</strong> 格式化数字</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_other_types.html"><strong aria-hidden="true">17.4.3.</strong> 格式化其他类型</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_values_for_debugging.html"><strong aria-hidden="true">17.4.4.</strong> 调试下的格式化</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_pointers_for_debugging.html"><strong aria-hidden="true">17.4.5.</strong> 调试下的指针格式化</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/referring_to_arguments_by_index_or_name.html"><strong aria-hidden="true">17.4.6.</strong> 通过索引或名字指向参数</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/dynamic_widths_and_precisions.html"><strong aria-hidden="true">17.4.7.</strong> 动态的宽度和精度</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/formatting_your_own_types.html"><strong aria-hidden="true">17.4.8.</strong> 格式化你自己的类型</a></li><li class="chapter-item "><a href="chapter_17/FormattingValues/using_the_formatting_language_in_your_own_code.html"><strong aria-hidden="true">17.4.9.</strong> 在你自己的代码使用格式化语言</a></li></ol></li><li class="chapter-item "><a href="chapter_17/RegularExpressions/regular_expressions.html"><strong aria-hidden="true">17.5.</strong> 正则表达式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/RegularExpressions/basic_regex_use.html"><strong aria-hidden="true">17.5.1.</strong> 基础</a></li><li class="chapter-item "><a href="chapter_17/RegularExpressions/building_regex_values_lazily.html"><strong aria-hidden="true">17.5.2.</strong> 创建惰性正则表达式的值</a></li></ol></li><li class="chapter-item "><a href="chapter_17/Normalization/normalization/.md.html"><strong aria-hidden="true">17.6.</strong> 标准化</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_17/Normalization/normalization_forms.html"><strong aria-hidden="true">17.6.1.</strong> 标准化格式</a></li><li class="chapter-item "><a href="chapter_17/Normalization/the_unicode-normalization_crate.html"><strong aria-hidden="true">17.6.2.</strong> Unicode标准化crate</a></li></ol></li></ol></li><li class="chapter-item "><a href="chapter_18/input_and_output.html"><strong aria-hidden="true">18.</strong> 第十八章 输入和输出</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/readers_and_writers.html"><strong aria-hidden="true">18.1.</strong> 读者和作者</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/readers.html"><strong aria-hidden="true">18.1.1.</strong> “读者”</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/buffered_readers.html"><strong aria-hidden="true">18.1.2.</strong> 缓冲区的读者</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/reading_lines.html"><strong aria-hidden="true">18.1.3.</strong> 写入行</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/collecting_lines.html"><strong aria-hidden="true">18.1.4.</strong> 收集行</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/writers.html"><strong aria-hidden="true">18.1.5.</strong> “作者”</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/files.html"><strong aria-hidden="true">18.1.6.</strong> 文件</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/seeking.html"><strong aria-hidden="true">18.1.7.</strong> 寻找</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/other_reader_and_writer_types.html"><strong aria-hidden="true">18.1.8.</strong> 其他读者和作者类型</a></li><li class="chapter-item "><a href="chapter_18/ReadersAndWriters/binary_data_compression_and_serialization.html"><strong aria-hidden="true">18.1.9.</strong> 二进制数据的压缩和序列化</a></li></ol></li><li class="chapter-item "><a href="chapter_18/FilesAndDirectories/files_and_directories/.md.html"><strong aria-hidden="true">18.2.</strong> 文件和目录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_18/FilesAndDirectories/OsStr_and_Path.html"><strong aria-hidden="true">18.2.1.</strong> OsStr和Path</a></li><li class="chapter-item "><a href="chapter_18/FilesAndDirectories/Path_and_PathBuf_Methods.html"><strong aria-hidden="true">18.2.2.</strong> Path和PathBuf方法</a></li><li class="chapter-item "><a href="chapter_18/FilesAndDirectories/filesystem_access_functions.html"><strong aria-hidden="true">18.2.3.</strong> 文件系统访问函数</a></li><li class="chapter-item "><a href="chapter_18/FilesAndDirectories/reading_directories.html"><strong aria-hidden="true">18.2.4.</strong> 读取目录</a></li><li class="chapter-item "><a href="chapter_18/FilesAndDirectories/platform-specific_features.html"><strong aria-hidden="true">18.2.5.</strong> 特定平台的特性</a></li></ol></li><li class="chapter-item "><a href="chapter_18/networking.html"><strong aria-hidden="true">18.3.</strong> 网络</a></li></ol></li><li class="chapter-item "><a href="chapter_19/concurrency.html"><strong aria-hidden="true">19.</strong> 第十九章 并发</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_19/Fork-JoinParallelism/fork-Join_parallelism.html"><strong aria-hidden="true">19.1.</strong> Fork-Join 并行性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_19/Fork-JoinParallelism/spawn_and_join.html"><strong aria-hidden="true">19.1.1.</strong> 生产</a></li><li class="chapter-item "><a href="chapter_19/Fork-JoinParallelism/error_handling_across_threads.html"><strong aria-hidden="true">19.1.2.</strong> 跨线程的错误处理</a></li><li class="chapter-item "><a href="chapter_19/Fork-JoinParallelism/sharing_immutable_data_across_threads.html"><strong aria-hidden="true">19.1.3.</strong> 跨线程分享不可变数据</a></li><li class="chapter-item "><a href="chapter_19/Fork-JoinParallelism/rayon.html"><strong aria-hidden="true">19.1.4.</strong> rayon</a></li><li class="chapter-item "><a href="chapter_19/Fork-JoinParallelism/revisiting_the_mandelbrot_set.html"><strong aria-hidden="true">19.1.5.</strong> 再看曼德勃罗集合</a></li></ol></li><li class="chapter-item "><a href="chapter_19/Channels/channels.html"><strong aria-hidden="true">19.2.</strong> 通道</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_19/Channels/sending_values.html"><strong aria-hidden="true">19.2.1.</strong> 发送值</a></li><li class="chapter-item "><a href="chapter_19/Channels/receiving_values.html"><strong aria-hidden="true">19.2.2.</strong> 接收值</a></li><li class="chapter-item "><a href="chapter_19/Channels/running_the_pipeline.html"><strong aria-hidden="true">19.2.3.</strong> 运行管道</a></li><li class="chapter-item "><a href="chapter_19/Channels/channel_features_and_performance.html"><strong aria-hidden="true">19.2.4.</strong> 通道的特性和性能</a></li><li class="chapter-item "><a href="chapter_19/Channels/thread_safety_send_and_sync.html"><strong aria-hidden="true">19.2.5.</strong> 线程安全性：发送和同步</a></li><li class="chapter-item "><a href="chapter_19/Channels/piping_almost_any_iterator_to_a_channel.html"><strong aria-hidden="true">19.2.6.</strong> 将几乎所有迭代器管道化为一个通道</a></li><li class="chapter-item "><a href="chapter_19/Channels/beyond_pipelines.html"><strong aria-hidden="true">19.2.7.</strong> 管道之外</a></li></ol></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/shared_mutable_state.html"><strong aria-hidden="true">19.3.</strong> 分享可变状态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_19/SharedMutableState/what_is_a_mutex.html"><strong aria-hidden="true">19.3.1.</strong> 什么是mutex</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/Mutex.html"><strong aria-hidden="true">19.3.2.</strong> Mutex</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/mut_and_Mutex.html"><strong aria-hidden="true">19.3.3.</strong> mut和Mutex</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/why_Mutexes_are_not_always_a_good_idea.html"><strong aria-hidden="true">19.3.4.</strong> 为什么Mutexes并不总是一个好想法</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/deadlock.html"><strong aria-hidden="true">19.3.5.</strong> 死锁</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/poisoned_Mutexes.html"><strong aria-hidden="true">19.3.6.</strong> 有毒的Mutexes</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/multi-producer_channels_using_mutexes.html"><strong aria-hidden="true">19.3.7.</strong> 多个生产者通道使用mutexes</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/read_or_Write_Locks(RwLock).html"><strong aria-hidden="true">19.3.8.</strong> 读或写锁(RwLock)</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/condition_variables(Condvar).html"><strong aria-hidden="true">19.3.9.</strong> 特定变量(Condvar)</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/atomics.html"><strong aria-hidden="true">19.3.10.</strong> 原子性</a></li><li class="chapter-item "><a href="chapter_19/SharedMutableState/global_variables.html"><strong aria-hidden="true">19.3.11.</strong> 全局变量</a></li></ol></li><li class="chapter-item "><a href="chapter_19/what_hacking_concurrent_code_in_rust_is_like.html"><strong aria-hidden="true">19.4.</strong> 在rust中编写并发代码...</a></li></ol></li><li class="chapter-item "><a href="chapter_20/macros.html"><strong aria-hidden="true">20.</strong> 第二十章 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_20/MacroBasics/macro_basics.html"><strong aria-hidden="true">20.1.</strong> 基本的宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_20/MacroBasics/basics_of_macro_expansion.html"><strong aria-hidden="true">20.1.1.</strong> 宏扩展的基础</a></li><li class="chapter-item "><a href="chapter_20/MacroBasics/unintended_consequences.html"><strong aria-hidden="true">20.1.2.</strong> 意想不到的影响</a></li><li class="chapter-item "><a href="chapter_20/MacroBasics/repetition.html"><strong aria-hidden="true">20.1.3.</strong> 重复</a></li></ol></li><li class="chapter-item "><a href="chapter_20/built-in_macros.html"><strong aria-hidden="true">20.2.</strong> 内置宏</a></li><li class="chapter-item "><a href="chapter_20/debugging_macros.html"><strong aria-hidden="true">20.3.</strong> 调试宏</a></li><li class="chapter-item "><a href="chapter_20/TheJsonMacro/the_json_macro.html"><strong aria-hidden="true">20.4.</strong> json!宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_20/TheJsonMacro/fragment_type.html"><strong aria-hidden="true">20.4.1.</strong> 破碎的类型</a></li><li class="chapter-item "><a href="chapter_20/TheJsonMacro/recursion_in_macros.html"><strong aria-hidden="true">20.4.2.</strong> 宏中的递归</a></li><li class="chapter-item "><a href="chapter_20/TheJsonMacro/using_traits_with_macros.html"><strong aria-hidden="true">20.4.3.</strong> 与宏一起使用traits</a></li><li class="chapter-item "><a href="chapter_20/TheJsonMacro/scoping_and_hygiene.html"><strong aria-hidden="true">20.4.4.</strong> 作用域的纯净</a></li><li class="chapter-item "><a href="chapter_20/TheJsonMacro/importing_and_exporting_macros.html"><strong aria-hidden="true">20.4.5.</strong> 导入和导出宏</a></li></ol></li><li class="chapter-item "><a href="chapter_20/avoiding_syntax_errors_during_matching.html"><strong aria-hidden="true">20.5.</strong> 匹配时避免语法错误</a></li><li class="chapter-item "><a href="chapter_20/beyond_macro_rules.html"><strong aria-hidden="true">20.6.</strong> 宏规则之外</a></li></ol></li><li class="chapter-item "><a href="chapter_21/unsafe_code.html"><strong aria-hidden="true">21.</strong> 第二十一章 “不安全的”代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_21/unsafe_from_what.html"><strong aria-hidden="true">21.1.</strong> 不安全的来源？</a></li><li class="chapter-item "><a href="chapter_21/UnsafeBlocks/unsafe_blocks.html"><strong aria-hidden="true">21.2.</strong> 不安全块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_21/unsafeBlocks/example_an_efficient_ascii_string_type.html"><strong aria-hidden="true">21.2.1.</strong> 例子：一个有效的ASCII字符串类型</a></li></ol></li><li class="chapter-item "><a href="chapter_21/unsafe_functions.html"><strong aria-hidden="true">21.3.</strong> 不安全的函数</a></li><li class="chapter-item "><a href="chapter_21/unsafe_block_or_unsafe_function.html"><strong aria-hidden="true">21.4.</strong> 不安全的块或不安全的函数？</a></li><li class="chapter-item "><a href="chapter_21/undefined_behavior.html"><strong aria-hidden="true">21.5.</strong> 未定义的行为</a></li><li class="chapter-item "><a href="chapter_21/unsafe_traits.html"><strong aria-hidden="true">21.6.</strong> 不安全的trait</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/raw_pointers.html"><strong aria-hidden="true">21.7.</strong> 原生指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_21/RawPointers/dereferencing_raw_pointers_safely.html"><strong aria-hidden="true">21.7.1.</strong> 安全的解引用原生指针</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/example_RefWithFlag.html"><strong aria-hidden="true">21.7.2.</strong> 例子：RefWithFlag</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/nullable_pointers.html"><strong aria-hidden="true">21.7.3.</strong> 可为空的指针</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/type_sizes_and_alignments.html"><strong aria-hidden="true">21.7.4.</strong> 类型大小和比对</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/pointer_arithmetic.html"><strong aria-hidden="true">21.7.5.</strong> 算术指针</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/moving_into_and_out_of_memory.html"><strong aria-hidden="true">21.7.6.</strong> 移进或移出内存</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/example_gapBuffer.html"><strong aria-hidden="true">21.7.7.</strong> 例子：gapBuffer</a></li><li class="chapter-item "><a href="chapter_21/RawPointers/panic_safety_in_unsafe_code.html"><strong aria-hidden="true">21.7.8.</strong> 不安全的代码中安全的panic</a></li></ol></li><li class="chapter-item "><a href="chapter_21/ForeignFunctionsCallingCAndCppFromRust/foreign_functions_calling_c_and_cpp_from_rust.html"><strong aria-hidden="true">21.8.</strong> 外部函数：从Rust中调用C和C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_21/ForeignFunctionsCallingCAndCppFromRust/finding_common_data_representations.html"><strong aria-hidden="true">21.8.1.</strong> 寻找通用的数据呈现</a></li><li class="chapter-item "><a href="chapter_21/ForeignFunctionsCallingCAndCppFromRust/declaring_foreign_functions_and_variables.html"><strong aria-hidden="true">21.8.2.</strong> 声明外部函数和变量</a></li><li class="chapter-item "><a href="chapter_21/ForeignFunctionsCallingCAndCppFromRust/using_functions_from_libraries.html"><strong aria-hidden="true">21.8.3.</strong> 从库中使用函数</a></li><li class="chapter-item "><a href="chapter_21/ForeignFunctionsCallingCAndCppFromRust/a_raw_interface_to_libgit2.html"><strong aria-hidden="true">21.8.4.</strong> libgit2中的一个原生接口</a></li><li class="chapter-item "><a href="chapter_21/ForeignFunctionsCallingCAndCppFromRust/a_safe_interface_to_libgit2.html"><strong aria-hidden="true">21.8.5.</strong> libgit2中的一个安全接口</a></li></ol></li><li class="chapter-item "><a href="chapter_21/conclusion.html"><strong aria-hidden="true">21.9.</strong> 总结</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">《Programming Rust》中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">译者序</h1>
<h2><a class="header" href="#动机" id="动机">动机</a></h2>
<p>《Programming Rust》对Rust初学者非常友好，然而遗憾的是，到目前为止(2020/06/03)这本书国内还没有译版，故我们决定翻译此书，来帮助那些可能还不习惯阅读英文技术文档但又想学习Rust的人。</p>
<h2><a class="header" href="#如何阅读" id="如何阅读">如何阅读</a></h2>
<ul>
<li>
<p>[推荐]请确保你的Rust版本&gt;=1.39并且安装了Cargo</p>
<ul>
<li>安装<a href="https://github.com/rust-lang/mdBook">文档构建工具</a>: <code>cargo install mdbook</code></li>
<li>将本仓库克隆到本地: <code>git clone https://github.com/TENX-S/Programming-Rust-Translation.git</code></li>
<li>切换到该仓库工作目录 <code>cd Programming-Rust-Translation</code></li>
<li>构建本书 <code>mdbook serve</code></li>
<li>根据提示访问: http://localhost:3000 或其他</li>
</ul>
</li>
<li>
<p>[在线版本] <a href="https://tenxs.life">记得收藏本网站哟</a></p>
</li>
</ul>
<h2><a class="header" href="#目标读者" id="目标读者">目标读者</a></h2>
<p>我们假定读者符合下列条件之一：</p>
<ul>
<li>已经了解或熟悉C/C++，<strong>懂得指针/引用的概念和内存管理</strong></li>
<li>掌握至少一种OOP编程语言(Python, Java, ...)</li>
</ul>
<h2><a class="header" href="#非目标读者" id="非目标读者">非目标读者</a></h2>
<p>若你不具备上述条件，但想挑战自己，满足自己的好奇心或其他。我们的观点是，这样学习Rust的效率将会非常低下，比难懂的更糟的是，你形成了错误的第一印象，这也许会对你以后的学习历程产生难以预料的影响。</p>
<h2><a class="header" href="#加入我们" id="加入我们">加入我们!</a></h2>
<p>这个<a href="https://github.com/TENX-S/Programming-Rust-Translation">项目</a>是开源的，如果您对Rust有相当程度的了解并对英语翻译有信心，欢迎提交您的译文。即使您只是Rust初学者，也可以将遇到的任何有关翻译上的疑惑反映到issues上。我们欢迎所有热情并充满信心的人。<a href="CONTRIBUTING.html">如何贡献？</a></p>
<h2><a class="header" href="#作者" id="作者">作者</a></h2>
<a href="https://github.com/TENX-S">
    <img src="https://avatars1.githubusercontent.com/u/40336192?s=460&amp" width="60px">
</a>
<a href="https://github.com/KallenW">
    <img src="https://avatars2.githubusercontent.com/u/66395882?s=460&amp" width="60px">
</a>
<a href="https://github.com/nobodyineverywhere">
    <img src="https://avatars0.githubusercontent.com/u/68425063?s=460&u=f8092416a9b3c509ad593e0e60106514e1c3854f&v=4" width="60px">
</a>
<h2><a class="header" href="#license" id="license">LICENSE</a></h2>
<p>Apache 2.0</p>
<h1 align="right">序言</h1>
<p>Rust是一门系统级编程语言</p>
<p>因为大多数程序员都不熟悉系统级编程语言，故最近有一些关于它的解释，而这正是本书内容的基础。</p>
<p>你关上笔记本，然后操作系统就会检测到这个动作，于是暂停所有正在运行的程序：关闭屏幕，并让电脑进入睡眠💤。后来，你打开笔记本：屏幕和其他东西都又打开了，并且每个程序都可以从它停止的地方开始运行。我们认为这是理所当然的，但系统级编程的程序员们为此编写了很多代码。</p>
<p>系统级编程应用于：</p>
<ul>
<li>操作系统</li>
<li>各种硬件设备</li>
<li>文件系统</li>
<li>数据库</li>
<li>在极其廉价的设备运行代码或设备必须非常可靠</li>
<li>密码学</li>
<li>媒体解码（用于读写音频、视频和图像文件的软件）</li>
<li>处理媒体（例如，语音识别或编辑照片的软件）</li>
<li>内存管理（例如，实现垃圾收集）</li>
<li>文本渲染（将文本和字体转换为像素）</li>
<li>开发高级编程语言（像JavaScript和Python)</li>
<li>网络</li>
<li>虚拟机和软件容器</li>
<li>科学中的模拟</li>
<li>游戏</li>
</ul>
<p>简而言之，系统级编程是资源受限的，它存在于每个字节和CPU周期中。</p>
<p><strong>支持一个基本应用程序所涉及的系统代码数量是惊人的。</strong></p>
<p>这本书不会教你系统级编程。事实上，如果你自己没进行过一些系统级编程，那么这本书涵盖的有关内存管理的许多细节乍一看会让你觉得很深奥但又没必要。而如果你是一位经验丰富的系统级编程的程序员，你会发现Rust是一种特殊的工具：它消除了困扰了整个行业几十年的主要的、大家都很熟悉的问题。</p>
<h2><a class="header" href="#目标读者-1" id="目标读者-1">目标读者</a></h2>
<p>如果您已经是一名系统级程序员，并且想使用C++的替代品，那么这本书就是为你准备的。如果您是任何编程语言(无论是C#、Java、Python、JavaScript或其他)的资深开发人员，这本书也适合你。</p>
<p>然而，你不只是需要学习Rust。要充分利用这门语言，你还需要获得一些系统级编程的经验。我们推荐阅读这本书，同时也在Rust中实现一些系统级编程方面的项目。利用Rust的速度、并发性和安全性来构建一些你以前从未构建过的东西。这篇序言开头的应用列表或许会给你一些思路。</p>
<h2><a class="header" href="#阅读姿势" id="阅读姿势">阅读姿势</a></h2>
<p>本书的前两章介绍了Rust，并在第3章讨论基本数据类型之前进行了简单的介绍。第4章和第5章讨论了所有权和引用的核心概念。我们建议按顺序读完前五章。</p>
<p>第6章到第10章涵盖了语言的基础知识:表达式(第6章)，错误处理(第7章)，crates和模块(第8章)，结构体(第9章)，枚举和模式(第10章)。在这里略读一下是可以的，但，相信我们，不要跳过错误处理这一章。</p>
<p>第11章涵盖了trait和泛型，这是你需要知道的最后两个重要概念。特征就像Java或c#中的接口。它们也是Rust支持将类型集成到语言本身的主要方式。第12章展示了trait如何支持操作符重载，第13章涵盖了更多的实用特征。</p>
<p>理解特性和泛型即可解锁本书的其余部分🍺。闭包和迭代器是两种重要的强大工具，不要错过它们哦，这两种工具将分别在第14章和第15章中介绍。之后可以按任意顺序阅读剩下的章节，也可以根据需要随意浏览。它们涵盖了语言的其余部分:集合(第16章)、字符串和文本(第17章)、输入和输出(第18章)、并发(第19章)、宏(第20章)和不安全(第21章)。</p>
<h2><a class="header" href="#本书中使用的惯例" id="本书中使用的惯例">本书中使用的惯例</a></h2>
<p>在本书中使用了以下排版惯例:</p>
<p><em>斜体</em>
表示新术语、url、电子邮件地址、文件名和文件扩展名。</p>
<p>固定宽度  用于程序段，以及在段落中引用程序元素，如变量或函数名、数据库、数据类型、环境变量、语句和关键字。</p>
<p><strong>等宽粗体</strong>
表示用户应该按字面输入的命令或其他文本。</p>
<p><em>固定宽度斜体</em>
表示应由用户提供的值或由上下文确定的值替换的文本。</p>
<p>|...|</p>
<blockquote>
<p>译者注：|...|表示略去了不重要的部分，通常是与编程无关的主题，下同。</p>
</blockquote>
<h2><a class="header" href="#使用代码示例" id="使用代码示例">使用代码示例</a></h2>
<p>补充材料(代码示例、练习等)可从https://github.com/oreillymedia/programming_rust 下载。</p>
<p>|...|</p>
<h1><a class="header" href="#第一章-为什么用rust" id="第一章-为什么用rust">第一章 为什么用Rust？</a></h1>
<p><strong>名人名言略</strong></p>
<p>自50年前我们开始用高级编程语言去写操作系统至今，系统级编程语言已经走过了一段相当长的路，但还有两个人人皆知的特定问题仍未解决。</p>
<ul>
<li>很难写出安全的代码，尤其困难的是在C/C++中正确地管理内存。几十年来，我们一直在忍受着由此带来的后果————安全漏洞，其最早的形式可追溯到1988年的Morris蠕虫病毒。</li>
<li>很难进行多线程编程，然而这却是充分利用现代机器性能的唯一方法。甚至是颇有经验的程序员处理多线程代码时也得小心翼翼：因为并发会导致一些新型bug，并使普通bug更难重现。</li>
</ul>
<p>而Rust正是：一门性能比肩C/C++，同时还注重安全和高效并发的语言。</p>
<p>Rust是一门由Mozilla和社区贡献者发明的新型系统级编程语言。与C/C++一样，Rust给程序员提供了管理内存的有效手段，并在语言的原生操作和运行该语言的机器的原始操作之间保持了密切的联系，帮助我们预测性能的开销。Rust的伟大愿景与Bjarne Stroustrup的论文&quot;Abstraction and the C++ Model&quot;中对C++期盼的一样：</p>
<blockquote>
<p>一般来说，由C++编写的代码遵循零开销原则：你不需要为了不使用的东西而付出什么。更进一步地说：你所正在使用的，已经是最好的代码了。</p>
</blockquote>
<p>为了这个愿景，Rust给自己设定了关于内存安全和可信任并发的目标。</p>
<p>达成上述目标的关键是Rust的新颖的所有权系统，移动(<em>moves</em>)和借用(brorrows)，编译时检查和小心谨慎的设计去完备Rust灵活的静态类型系统。所有权系统为每一个值都明确了生命周期，使得语言的核心部分不需要实现垃圾回收(GC)，并为管理其他类型资源如套接字和文件句柄使用了合理且灵活的接口。“移动”将值从一个所有者转移到另一个，而“借用”可以让代码暂时使用一个值却不影响它到所有权。因为许多程序员在此之前从未遇到过这些特性，我们将在第四章和第五章详细地讲解。</p>
<p>Rust不是一门真正的面向对象语言，尽管它具有一些面向对象的特性。Rust不是一门函数式编程语言，尽管它确实倾向于函数式编程那样，让计算结果的影响更加明确。Rust在某种程度上类似于C/C++，但这些语言的习惯用法却并不适用于Rust。因此，经典的Rust代码在很大程度上并不类似于C/C++的代码。所以最好还是保留对什么是Rust的判断，然后看看习惯了这种语言之后你的想法。</p>
<p>为了在现实应用中获得设计上的反馈，Mozilla用Rust开发了一个新的Web浏览器引擎Servo，Servo的需求和Rust的愿景很好地匹配：浏览器性能良好并安全地处理不可信的数据。Servo使用Rust的安全并发性去处理C/C++无法并行化的工作。事实上，Servo和Rust是一起成长起来的，Servo使用最新的语言特性，而Rust则是根据Servo开发人员的反馈一点一点进化的。</p>
<h1><a class="header" href="#类型安全" id="类型安全">类型安全</a></h1>
<h1><a class="header" href="#第二章-一次rust之旅" id="第二章-一次rust之旅">第二章 一次Rust之旅</a></h1>
<h1><a class="header" href="#下载和安装rust" id="下载和安装rust">下载和安装Rust</a></h1>
<h1><a class="header" href="#一个简单的函数" id="一个简单的函数">一个简单的函数</a></h1>
<h1><a class="header" href="#编写并运行单元测试" id="编写并运行单元测试">编写并运行单元测试</a></h1>
<h1><a class="header" href="#处理命令行参数" id="处理命令行参数">处理命令行参数</a></h1>
<h1><a class="header" href="#并发" id="并发">并发</a></h1>
<h1><a class="header" href="#曼德勃罗集合的本质" id="曼德勃罗集合的本质">曼德勃罗集合的本质</a></h1>
<h1><a class="header" href="#解析命令行参数" id="解析命令行参数">解析命令行参数</a></h1>
<h1><a class="header" href="#将像素映射为复数" id="将像素映射为复数">将像素映射为复数</a></h1>
<h1><a class="header" href="#画出集合" id="画出集合">画出集合</a></h1>
<h1><a class="header" href="#写入图像文件" id="写入图像文件">写入图像文件</a></h1>
<h1><a class="header" href="#一个并发的曼德勃罗程序" id="一个并发的曼德勃罗程序">一个并发的曼德勃罗程序</a></h1>
<h1><a class="header" href="#运行曼德勃罗绘图器" id="运行曼德勃罗绘图器">运行曼德勃罗绘图器</a></h1>
<h1><a class="header" href="#隐藏的安全性" id="隐藏的安全性">隐藏的安全性</a></h1>
<h1 align="right">基本类型</h1>
<p align="right" style="font-style: Italic;">世界上有许多种好书是因为有很多种人，并且每个人都想读点与众不同的东西。</p>
<br /><p align="right">—Lemony Snicket<p>
<p>Rust的基本类型的设计基于下面几个目标：</p>
<p><em>安全</em></p>
<blockquote>
<p>通过程序的类型检查，Rust编译器排除了所有类别的常见错误。通过使用类型安全的替代品去替换空指针和未经检测的元组，Rust甚至能够消除其他语言中因常见的崩溃原因引发的错误。</p>
</blockquote>
<p><em>效率</em></p>
<blockquote>
<p>程序员可以对Rust程序中如何呈现内存中的值进行细粒度的控制，并且能选择自己知道处理器可以有效处理的类型。程序没有必要为了不使用的通用性和灵活性付出代价。</p>
</blockquote>
<p>简洁</p>
<blockquote>
<p>[<strong>TODO:未明确的翻译</strong>]Rust不需要程序员以在代码中写类型的方式提供导向[<strong>Rust manages all of this without requiring too much guidance from the programmer in the form of types written out in the code.</strong>]，它会自己处理好这些事情。与相似的C++的程序相比来说，Rust程序中的类型更整洁。</p>
</blockquote>
<p>相较于使用解释器或者即时编译(JIT)的编译器，Rust旨在使用预编译：在开始执行之前，整个程序就已经转为机器代码了。Rust的类型系统帮助预编译器为程序使用的值选择适合的机器级表示：可以预测其性能的表现并完全使用机器的功能。</p>
<p>Rust是一个静态类型的语言：程序不会实时运行，编译会检查所有可能的执行路径，将仅与其类型一致的方式使用值。这允许Rust去提前捕捉程序的错误同时这也对Rust的安全保证至关重要。</p>
<p>相较于JavaScript或Python这种动态类型语言，Rust需要你提前计划：你必须声明函数的参数类型和返回值的类型，结构成员的类型和一些其他构造。然而，Rust的两个特性使得其麻烦程度比你预期的要少：</p>
<ul>
<li>给定一个你声明的类型，Rust会为你推断出剩下中的大多数。实际上，通常只有一种类型适用于给定的变量或表达式；在这种情况下，Rust允许你忽略该类型，例如，你可以向下面这样声明函数中的每种类型：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn build_vector() -&gt; Vec&lt;i16&gt; {
    let mut v: Vec&lt;i16&gt; = Vec::&lt;i16&gt;::new();
    v.push(10i16);
    v.push(20i16);
    v
}

<span class="boring">}
</span></code></pre></pre>
<p>但这样就显得重复且杂乱无章了。从给定了函数的返回值类型可以明显的看出<code>v</code>的类型必然是<code>Vec&lt;i16&gt;</code>，一个存储了16位有符号整数的向量；其他类型可能不起作用。从以上我们可以得知，所定义的vector的每一个元素类型必须为<code>i16</code>。这正是Rust进行类型推断的推理方式，允许你向下面这样写：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn build_vector() -&gt; Vec&lt;i16&gt; {
    let mut v: Vec&lt;i16&gt; = Vec::&lt;i16&gt;::new();
    v.push(10);
    v.push(20);
    v
}

<span class="boring">}
</span></code></pre></pre>
<p>这两个函数定义完全等价；对这两个函数而言，Rust会生成相同的机器代码，类型推断使得动态语言的可读性大大提高，同时也能捕捉编译时的错误。</p>
<ul>
<li>可定义泛型函数：当一个函数的目的和实现足够宽泛的时候，你可以定义其在任何类型集上以满足必要的标准。单个定义可以涵盖一组开放式用例。<br/>在Python和JavaScript中，函数的行为的很自然：一个函数可以操控任何其所需的拥有属性和方法的值，（这个特性被称为鸭子类型：如果它活动起来像鸭子，那么他就是鸭子）但这个灵活性也恰恰使得让这些语言很难提前发现类型错误。测试往往是捕捉类似错误的唯一办法。<br />Rust的泛型函数赋予语言同样的自由度，并且仍然在编译时捕捉类型错误。尽管具有灵活性，但是泛型函数和非泛型函数的效率一致。我们会在第11章中讨论泛型函数。</li>
</ul>
<p>下面是你在Rust中会看见的几种类型的总结。这个表格给出了Rust的原生类型，标准库中很常见的类型和用户自定义类型的例子：</p>
<blockquote>
<p>译者注：限于时间和精力，图片暂不做翻译，下同</p>
</blockquote>
<p><img src="chapter_3/../img/img-book/ch3-01.png" alt="" />
<img src="chapter_3/../img/img-book/ch3-02.png" alt="" />
除了以下列出的，这些类型中的大多数本章都会涉及：</p>
<ul>
<li>我们在第九章单独讲<code>struct</code></li>
<li>我们将在第十章单独讲enumrated类型</li>
<li>我们在第十一章介绍特性（trait）</li>
<li>我们在这里会介绍一些<code>String</code>和<code>&amp;str</code>的要点，但在第十七章中提供更多细节</li>
<li>我们在第十四章介绍函数和闭包类型</li>
</ul>
<h2><a class="header" href="#机器类型" id="机器类型">机器类型</a></h2>
<br />
Rust的类型系统基于一组固定宽度的数字类型，并匹配几乎所有现代处理器直接在硬件中实现的类型，以及布尔和字符类型。
<p>Rust的数字类型的名称遵循常规模式，以位为单位拼写其宽度及其使用的表示形式：
<img src="chapter_3/MachineTypes/../../img/img-book/ch3-03.png" alt="" /></p>
<p>在这里，机器字是代码在运行的机器上的地址的大小，通常为32位或64位。<br /></p>
<h1><a class="header" href="#整数类型" id="整数类型">整数类型</a></h1>
Rust的无符号整数类型全部用来表示正值和零：
<p><img src="chapter_3/MachineTypes/../../img/img-book/ch3-04.png" alt="" /></p>
<p>Rust的带符号整数类型使用两者的补码表示形式，并使用与相应的无符号类型相同的位模式来覆盖正值和负值的范围：</p>
<p><img src="chapter_3/MachineTypes/../../img/img-book/ch3-05.png" alt="" /></p>
<p>Rust通常将u8类型用于字节值。例如，从文件或套接字读取数据将产生u8值流。
不同于C/C++，Rust将字符类型区别与数字类型；一个<code>char</code>既不是<code>u8</code>也不是<code>i8</code>，我们将稍后讲到<code>char</code>类型。</p>
<p><code>usize</code>和<code>isize</code>类型类似与C/C++中的<code>size_t</code>和<code>ptrdiff_t</code>，<code>usize</code>类型是无符号的而<code>isize</code>类型是带符号的。它们的精确度依赖于目标机器地址空间的大小：它们在32位架构上是32位长的，在64位架构上是64位长的。Rust规定数组索引是<code>usize</code>的。表示数组或向量的大小或者某种数据结构所含元素的数量的值一般都用<code>usize</code>类型。
在调试环境下，Rust会检测算数溢出：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let big_val = std::i32::MAX;
    let x = big_val + 1;

<span class="boring">}
</span></code></pre></pre>
<p>在发型版本中，这个加法的结果会变成一个负数（不同于C++，带符号整数溢出是未定义的行为）。但是除非你想永远放弃调试，依靠于这样的行为不是一个好主意。当你想到得到溢出算术结果时，用这个方法：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let x = big_val.wrapping_add(1);

<span class="boring">}
</span></code></pre></pre>
<p>Rust中的整数字面量可以用一个后缀来指示其类型：<code>42u8</code>是一个<code>u8</code>，<code>1729isize</code>是一个<code>isize</code>。你可以忽略一个整数字面量的后缀，那样的话Rust会尝试从上下文中推导出它的类型。这个推导通常会定义一个特别的类型，但有时几个类型中任意一个都有效。在这种情况下，如果<code>i32</code>类型在那几个可能性中，Rust会默认选择它。否则，Rust会将这种模棱两可的情况视为一个错误并报出。</p>
<p>前缀<code>0x</code>，<code>0o</code>和<code>0b</code>表示十六进制，八进制和二进制。</p>
<p>为了使长整数更具可读性，你可以在数字中插入下划线。比如，你可以这样写最大的<code>u32</code>整数的值：<code>4_294_967_295</code>。下划线具体放在哪里无关紧要，所以你可以在十六进制或二进制中每隔四个而不是三个来放置下划线，比如<code>0xffff_ffff</code>或者将类型后缀与数字分离<code>127_u8</code>。</p>
<p>下面是一些整数字面量的例子：</p>
<p><img src="chapter_3/MachineTypes/../../img/img-book/ch3-06.png" alt="" /></p>
<p>尽管数字类型和<code>char</code>类型是分开的，Rust却提供了字节字面量(byte literals)，字面量的字符类似于<code>u8</code>的值：<code>b'X'</code>表示作为一个字符<code>X</code>的ASCII码（u8值）。例如：我们都知道字符<code>'A'</code>的ASCII码是65，字面量<code>b'A'</code>和<code>65u8</code>是完全等价的。字节字面量中只会出现ASCII字符。</p>
<p>下面几个字符你不能仅仅使用单引号来表示，因为那会使得句法上模棱两可或者难以阅读。所以需要一个反斜线放在它们前面。</p>
<p><img src="chapter_3/MachineTypes/../../img/img-book/ch3-07.png" alt="" /></p>
<p>如果一些字符难以读写，你可以使用它们的十六进制码来代替。一个形如<code>b'\xHH'</code>的字节字面量，HH是任意两个十六进制数，代表了值为HH的字节。例如，因为‘escape’控制字符的ASCII码为27或者十六进制下的<code>1B</code>，你可以将其写为<code>b'\x1b'</code>的字节字面量。因为字节字面量仅仅只是<code>u8</code>值的另一种表示，所以当考虑一个简单的数字字面量是否更易读：即当你只想强调一个值代表ASCII码时，可能用<code>b'\x1b'</code>相比于仅用27更符合情理。</p>
<p>你可以使用<code>as</code>算子对整数进行类型转换，我们将在第六章：表达式中类型转换这一节解释转换的细节，但先看下面几个例子吧：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    assert_eq!(    10_i8 as u16, 10_u16);
    assert_eq!( 2525_u16 as i16, 2525_i16);

    assert_eq!(   -1_i16 as i32, -1_i32);
    assert_eq!(65535_u16 as i32, 65535_i32);
    // 超出目标范围的转换所产生的值为原始值模2^N
    // 其中N是目标的宽度（以位为单位）
    // 这有时被称为截断。
    assert_eq!( 1000_i16 as u8, 232_u8);
    //  1000 mod 2^8 = 232
    assert_eq!(65535_u32 as i16, -1_i16);
    //65535 mod 2^16 = -1

    assert_eq!(     -1i8 as u8, 255_u8);
    //    -1 mod 2^8 = 255
    assert_eq!(   255_u8 as i8, -1_i8);
    //   255 mod 256 = -1

<span class="boring">}
</span></code></pre></pre>
<p>类似于任何其他类型的值，整数也有方法。标准库提供了一些基本的操作，你可以从在线文档中进行查阅。注意到那个文档包含类型本身的单独页面（例如，搜索&quot;<code>i32</code> (primitive type)&quot;）,对于该类型的模块（搜索“<code>std::i32</code>”）。例如：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    assert_eq!(2u16.pow(4), 16);           // 求幂
    assert_eq!((-4i32).abs(), 4);          // 绝对值
    assert_eq!(0b101101u8.count_ones(), 4);// 数量

<span class="boring">}
</span></code></pre></pre>
<p>这里的字面量的类型后缀是必需的：Rust如果不知道值的类型就不能寻找它的方法。在真实的代码中，然而，通常会有其他上下文来消除类型的歧义，因此后缀是非必需的。</p>
<h1><a class="header" href="#浮点类型" id="浮点类型">浮点类型</a></h1>
Rust提供IEEE单双精度的浮点了行。且遵循IEEE 754-2008规范，这些类型包含正负无穷，不同的正零和负零值以及一个非数字值：
![](../../img/img-book/ch3-08.png)
<p>Rust的<code>f32</code>和<code>f64</code>对应于支持IEEE浮点的C/C++实现的float和double类型，并且也对应于习惯使用IEEE浮点的Java。</p>
<p>浮点字面量的一般形式如下图所示：
<img src="chapter_3/MachineTypes/../../img/img-book/ch3-09.png" alt="" />
整数部分后面的三个部分都是可选的，但至少要出现一个以区别于整数字面量，小数部分(fractional part)可能包含一个单独的小数点，所以 <code>5.</code>是一个合法的常数。</p>
<p>如果一个浮点数没有类型后缀，Rust会从上下文中推断它是<code>f32</code>还是<code>f64</code>，如果都有可能，则默认为<code>f64</code>。（类似的，C/C++和Java都把无后缀的浮点字面里看成是<code>double</code>值。）为了类型推断，Rust将整数字面量和浮点字面量视为不同的类：即永远不会将一个整数字面量推断为浮点类型，反之亦然。
下面是一些浮点字面量的例子：
<img src="chapter_3/MachineTypes/../../img/img-book/ch3-10.png" alt="" /></p>
<p>标准库的<code>std::f32</code>和<code>std::f64</code>模块定义里IEEE要求的特殊值像<code>INFINITY,</code>，<code>NEG_INFINITY</code>（负无穷），<code>NAN</code>（非数字，not a number），还有<code>MIN</code>和<code>MAX</code>（最大和最小的有限值）。<code>std::f32</code>和<code>std::f64</code>模块提供了多种常见的数学常量像<code>E</code>,<code>PI</code>和根号2。</p>
<p><code>f32</code>和<code>f64</code>类型题哦那个了完整的数学计算方法；例如，<code>2f64.sqrt()</code>是双精度的根号2。标准库文档使用&quot;<code>f32</code> (primitive type)&quot;和“<code>f64</code> (primitive type)”来描述它们：
下面是一些例子：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);
    assert_eq!(-1.01f64.floor(), -1.0);
    assert!((-1. / std::f32::INFINITY).is_sign_negative());

<span class="boring">}
</span></code></pre></pre>
<p>正如之前所述，通常在实际代码中，你不需要写这些类型后缀因为上文会决定这些类型。然而，如果不是这样，由此引发的错误信息会令人惊讶。举例，下面这行代码无法通过编译：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    println!(&quot;{}&quot;, (2.0).sqrt());

<span class="boring">}
</span></code></pre></pre>
<p>Rust提出:
<pre>error: no method named sqrt found for type `{float}` in the current scope</pre>
这令人意想不到；除了浮点类型，还有哪里能找到<code>sqrt</code>方法呢？解决的办法是用一种或另一种方式声明你想要的类型：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    println!(&quot;{}&quot;, (2.0_f64).sqrt());
    println!(&quot;{}&quot;, f64::sqrt(2.0));

<span class="boring">}
</span></code></pre></pre>
<p>不同于C/C++，Rust几乎没有隐式类型转换。如果一个函数需要一个<code>f64</code>的参数，则传递<code>i32</code>的值作为其参数是错误的。事实上，即时每个<code>i16</code>的值都是<code>i32</code>的值，Rust也不会将<code>i16</code>的值隐式转换为<code>i32</code>的值。但是这里的关键词是<em>隐含的</em>：你始终可以使用<code>as</code>运算符写出明确的转换：<code>i as f64</code>或者<code>x as i32</code>。缺少隐式转换会使得Rust的表达式相较于类似的C/C++代码更冗长。然而，有一份完善的记录表明，隐式整数转换会引起错误和安全漏洞；根据我们的经验，在Rust中写出数字转换使我们警惕了本来会错过的问题。我们会在第六章：表达式中类型转换这一节解释转换的细节。</p>
<h1><a class="header" href="#布尔类型" id="布尔类型">布尔类型</a></h1>
<p>Rust的布尔类型<code>bool</code>具有通常的两个值，<code>true</code>和<code>false</code>。像<code>==</code>和<code>&lt;</code>这样的比较符提供了<code>bool</code>值：<code>2&lt;5</code>是<code>true</code>，许多语言允许你在需要布尔值的上下文中使用其他类型的值：C/C++隐式地将字符，整数，浮点数和指针转换为布尔值，因此，它们可以直接用作<code>if</code>或<code>while</code>语句中的条件。Python允许你在布尔值的上下文中使用字符串，列表，字典，甚至集合，如果这些值是非空的，将其视为<code>true</code>。然而，Rust在这一点上非常严格：像<code>if</code>和<code>while</code>这样的控制结构要求其条件为布尔表达式，逻辑运算符<code>&amp;&amp;</code>和<code>||</code>也是如此。你必须写成<code>if x != 0 {...}</code>而不仅仅是<code>if x {...}</code>。</p>
<p>Rust的<code>as</code>算子可以将bool类型转为整数类型：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    assert_eq!(false as i32, 0);
    assert_eq!(true  as i32, 1);

<span class="boring">}
</span></code></pre></pre>
<p>然而，<code>as</code>不会反方向转换，即从数字类型到<code>bool</code>。相反的，你必须明确地写出类似于<code>x != 0</code>这样的比较。</p>
<p>尽管一个布尔值仅需一个位来表示它，Rust会使用内存中一整个字节在存储布尔值，所以你可以创建一个指向它的指针。</p>
<h1><a class="header" href="#字符" id="字符">字符</a></h1>
Rust的字符类型`char`代表了单个的32位的Unicode字符。
Rust位单个字符单独使用`char`类型，但是为字符串和文字流使用UTF-8编码。所以，一个`String`表示它的文本是一个UTF-8的字节序列，而不是一个字符数组。
<p>字符字面量由单引号括起来的字符，像<code>'8'</code>或者<code>'!'</code>。你可以使用任何你喜欢的Unicode字符：<code>'錆'</code>是一个<code>char</code>字面量，表示日本汉字<em>sabi</em>(rust)。</p>
<p>与字节文字一样，一些字符需要反斜杠转义：
<img src="chapter_3/MachineTypes/../img/img-book/ch3-11.png" alt="" /></p>
<p>如果你愿意，你可以使用十六进制写出字符的UniCode的码位点：</p>
<ul>
<li>如果字符的码位点在U+0000到U+007F范围内（也就是说，如果它的范围是ASCII的字符集合），那么你可以将字符写为'\xHH'，其中HH是一个两位的十六进制数字。例如，字符字面量<code>'*'</code>和<code>'\x2A'</code>是等价的，因为字符 <code>*</code>的码位点是42，或者十六进制下的2A。</li>
<li>你可以将任何Unicode字符写为<code>'\u{HHHHHH}'</code>，HHHHHH代表1至6位长的十六进制数。例如，字符字面量<code>'\u{CA0}'</code>代表字符“ಠ”，是不赞成的表情的UniCode中的一个卡纳达语字符，“ಠ_ಠ”。同样的字面量也可以简单的写成<code>'ಠ'</code>.</li>
</ul>
<p>一个<code>char</code>始终是范围为0x0000到0xD7FF或者0xE000到0x10FFFF的Unicode码位点。一个<code>char</code>永远不会是代理对的一半[A char is never a surrogate pair half]（即，码位点从0xD800到0xDFFF），或者Unicode码位空间之外的一个值（即，大于0x10FFFF）。Rust使用类型系统和动态检查确保<code>char</code>值始终在允许范围内。</p>
<p>Rust永远不会在<code>char</code>和其他类型间进行隐式转换。你可以使用算子<code>as</code>将一个<code>char</code>转换为一个整数类型；对小于32位的类型，字符值的高位被截断：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    assert_eq!('*' as i32, 42);
    assert_eq!('ಠ' as u16, 0xca0);
    assert_eq!('ಠ' as i8, -0x60); //U+0CA0截断为8为，带符号

<span class="boring">}
</span></code></pre></pre>
<p>从另一个方向看，<code>u8</code>是算子<code>as</code>转换<code>char</code>所使用的唯一类型：Rust想让as算子执行小代价，可靠的转换，但是<code>u8</code>以外的每个整数类型都包含不允许的Unicode代码点的值，因此这些转换需要在运行时检查。相反地，标准库函数<code>std::char::from_u32</code>接受任何<code>u32</code>值并返回一个<code>Option&lt;char&gt;</code>：如果这个<code>u32</code>是一个非法的Unicode码位点，那么<code>from_u32</code>返回<code>None</code>；否则，它返回<code>Some(c)</code>，c是一个<code>char</code>。</p>
<p>标准库为字符提供了一些有用的方法，你可以从在线文档中搜索“<code>char</code> (primitive type)”，对于模块“<code>std::char</code>”来说。举例如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    assert_eq!('*'.is_alphabetic(), false);
    assert_eq!('β'.is_alphabetic(), true);
    assert_eq!('8'.to_digit(10), Some(8));
    assert_eq!('ಠ'.len_utf8(), 3);
    assert_eq!(std::char::from_digit(2, 10), Some('2'));

<span class="boring">}
</span></code></pre></pre>
<p>自然，孤立的单个字符不如字符串和文本流那么有趣。我们将在本章的字符串类型这一节广泛地讨论Rust标准库中的<code>String</code>类型和文本处理。</p>
<h2><a class="header" href="#元组" id="元组">元组</a></h2>
元组是各种类型的若干元素的集合。你可以将一个元组写为一个用逗号分隔，圆括号括起的元素序列。例如，`('Brazil', 1985)`是一个元组，其第一个元素是静态分配的字符串，第二个元素是一个整数；它的类型是`(&str, i32)`（或者是任何Rust为1985推断出的整数类型）。给定一个元组`t`，你可以用`t.0`，`t.1`等等获取它的元素。
<p>元组不太像数组：一方面，元组的每个元素的类型可以互不相同，但数组的元素的类型必须一致。另外，元组只允许常数作为索引，像<code>t.4</code>。你不能写成<code>t.i</code>或者<code>t[i]</code>去索引第i个元素。</p>
<p>Rust代码中元组类型常被用作从一个函数返回多个值。例如，<code>split_at</code>方法作用与字符串切片上，将一个字符串分为两半并返回它们，它的声明类似于这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str);
    
<span class="boring">}
</span></code></pre></pre>
<p>它的返回类型<code>(&amp;str, &amp;str)</code>是包含两个字符串切片的元组。你可以使用元组解构（pattern-matching syntax）将返回值的每个元素分配给不同的变量：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let text = &quot;I see the eigenvalue in thine eye&quot;;
    let (head, tail) = text.split_at(21);
    assert_eq!(head, &quot;I see the eigenvalue &quot;);
    assert_eq!(tail, &quot;in thine eye&quot;);

<span class="boring">}
</span></code></pre></pre>
<p>下面这个比解构更易读：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let text = &quot;I see the eigenvalue in thine eye&quot;;
    let temp = text.split_at(21);
    let head = temp.0;
    let tail = temp.1;
    assert_eq!(head, &quot;I see the eigenvalue &quot;);
    assert_eq!(tail, &quot;in thine eye&quot;);

<span class="boring">}
</span></code></pre></pre>
<p>你还可以看到元组被用作一种最小-drama结构类型。在第二章提到的Mandelbrot程序中，我们需要给函数传递图像的宽度和高度，让它绘出该图像并写入磁盘。我们可以声明一个包含宽度和高度成员的结构，但是对这么显而易见的事情来说这样的声明过于繁杂了，所以我们就用一个元组。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 将缓冲区“ pixels”（其大小由“ bounds”指定）写入名为“ filename”的文件。
fn write_image(filename: &amp;str, pixels: &amp;[u8], bounds: (usize, usize)) -&gt; Result&lt;(), std::io::Error&gt; { ... }

<span class="boring">}
</span></code></pre></pre>
<p><code>bound</code>参数的类型是<code>(usize, usize)</code>，即包含两个<code>usize</code>值的元组。我们固然可以把宽度和高度的参数分开写，并且这两种方式得到的机器码大致相同。这事关声明是否清楚，让人理解。我们将大小视为一个整体的值，而不是两个。使用元组可以让代码与我们的意愿一致。</p>
<h1><a class="header" href="#指针类型" id="指针类型">指针类型</a></h1>
<h1><a class="header" href="#引用" id="引用">引用</a></h1>
<h1><a class="header" href="#盒子" id="盒子">盒子</a></h1>
<h1><a class="header" href="#原生指针" id="原生指针">原生指针</a></h1>
<h1><a class="header" href="#数组向量和切片" id="数组向量和切片">数组，向量和切片</a></h1>
<h1><a class="header" href="#向量" id="向量">向量</a></h1>
<h1><a class="header" href="#向量-1" id="向量-1">向量</a></h1>
<h1><a class="header" href="#一个元素一个元素地构造向量" id="一个元素一个元素地构造向量">一个元素一个元素地构造向量</a></h1>
<h1><a class="header" href="#切片" id="切片">切片</a></h1>
<h1><a class="header" href="#字符串类型" id="字符串类型">字符串类型</a></h1>
<h1><a class="header" href="#字符串字面量" id="字符串字面量">字符串字面量</a></h1>
<h1><a class="header" href="#字节字符串" id="字节字符串">字节字符串</a></h1>
<h1><a class="header" href="#内存中的字符串" id="内存中的字符串">内存中的字符串</a></h1>
<h1><a class="header" href="#字符串" id="字符串">字符串</a></h1>
<h1><a class="header" href="#使用字符串" id="使用字符串">使用字符串</a></h1>
<h1><a class="header" href="#其他像字符串的类型" id="其他像字符串的类型">其他像字符串的类型</a></h1>
<h1><a class="header" href="#基本类型之外" id="基本类型之外">基本类型之外</a></h1>
<h1><a class="header" href="#第四章-所有权" id="第四章-所有权">第四章 所有权</a></h1>
<h1><a class="header" href="#第四章-所有权-1" id="第四章-所有权-1">第四章 所有权</a></h1>
<h1><a class="header" href="#移动" id="移动">移动</a></h1>
<h1><a class="header" href="#其他会引发移动的操作" id="其他会引发移动的操作">其他会引发移动的操作</a></h1>
<h1><a class="header" href="#移动和控制流" id="移动和控制流">移动和控制流</a></h1>
<h1><a class="header" href="#移动和索引元素" id="移动和索引元素">移动和索引元素</a></h1>
<h1><a class="header" href="#复制类型移动的例外" id="复制类型移动的例外">复制类型：移动的例外</a></h1>
<h1><a class="header" href="#rc和arc共享所有权" id="rc和arc共享所有权">Rc和Arc：共享所有权</a></h1>
<h1><a class="header" href="#第五章-引用" id="第五章-引用">第五章 引用</a></h1>
<h1><a class="header" href="#引用作为值" id="引用作为值">引用作为值</a></h1>
<h1><a class="header" href="#引用rust-vs-c" id="引用rust-vs-c">引用：Rust vs C++</a></h1>
<h1><a class="header" href="#赋予引用" id="赋予引用">赋予引用</a></h1>
<h1><a class="header" href="#引用的引用" id="引用的引用">引用的引用</a></h1>
<h1><a class="header" href="#比较引用" id="比较引用">比较引用</a></h1>
<h1><a class="header" href="#引用永远不会为空" id="引用永远不会为空">引用永远不会为空</a></h1>
<h1><a class="header" href="#借用任意表达式的引用" id="借用任意表达式的引用">借用任意表达式的引用</a></h1>
<h1><a class="header" href="#切片和trait-object的引用" id="切片和trait-object的引用">切片和trait object的引用</a></h1>
<h1><a class="header" href="#引用安全" id="引用安全">引用安全</a></h1>
<h1><a class="header" href="#借用一个当前作用域的变量" id="借用一个当前作用域的变量">借用一个当前作用域的变量</a></h1>
<h1><a class="header" href="#接收作为引用的参数" id="接收作为引用的参数">接收作为引用的参数</a></h1>
<h1><a class="header" href="#传递作为引用的参数" id="传递作为引用的参数">传递作为引用的参数</a></h1>
<h1><a class="header" href="#返回引用" id="返回引用">返回引用</a></h1>
<h1><a class="header" href="#包含引用的结构体" id="包含引用的结构体">包含引用的结构体</a></h1>
<h1><a class="header" href="#独立的生命周期参数" id="独立的生命周期参数">独立的生命周期参数</a></h1>
<h1><a class="header" href="#忽略生命周期参数" id="忽略生命周期参数">忽略生命周期参数</a></h1>
<h1><a class="header" href="#共享-vs-可变" id="共享-vs-可变">共享 vs 可变</a></h1>
<h1><a class="header" href="#从都是对象引用的苦海中挣脱" id="从都是对象引用的苦海中挣脱">从都是对象引用的苦海中挣脱</a></h1>
<h1><a class="header" href="#第六章-表达式" id="第六章-表达式">第六章 表达式</a></h1>
<h1><a class="header" href="#一个基于表达式的语言" id="一个基于表达式的语言">一个基于表达式的语言</a></h1>
<h1><a class="header" href="#块和分号" id="块和分号">块和分号</a></h1>
<h1><a class="header" href="#声明" id="声明">声明</a></h1>
<h1><a class="header" href="#if和match" id="if和match">if和match</a></h1>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<h1><a class="header" href="#循环" id="循环">循环</a></h1>
<h1><a class="header" href="#return表达式" id="return表达式">return表达式</a></h1>
<h1><a class="header" href="#为什么rust有循环" id="为什么rust有循环">为什么rust有循环</a></h1>
<h1><a class="header" href="#函数和方法调用" id="函数和方法调用">函数和方法调用</a></h1>
<h1><a class="header" href="#字段和元素" id="字段和元素">字段和元素</a></h1>
<h1><a class="header" href="#引用操作符" id="引用操作符">引用操作符</a></h1>
<h1><a class="header" href="#算术位比较和逻辑操作符" id="算术位比较和逻辑操作符">算术，位，比较和逻辑操作符</a></h1>
<h1><a class="header" href="#赋值" id="赋值">赋值</a></h1>
<h1><a class="header" href="#类型转换" id="类型转换">类型转换</a></h1>
<h1><a class="header" href="#闭包" id="闭包">闭包</a></h1>
<h1><a class="header" href="#优先级和结合性" id="优先级和结合性">优先级和结合性</a></h1>
<h1><a class="header" href="#前瞻" id="前瞻">前瞻</a></h1>
<h1><a class="header" href="#错误处理" id="错误处理">错误处理</a></h1>
<h1><a class="header" href="#panic" id="panic">Panic</a></h1>
<h1><a class="header" href="#栈展开" id="栈展开">栈展开</a></h1>
<h1><a class="header" href="#丢弃" id="丢弃">丢弃</a></h1>
<h1><a class="header" href="#result" id="result">Result</a></h1>
<h1><a class="header" href="#捕捉错误" id="捕捉错误">捕捉错误</a></h1>
<h1><a class="header" href="#result类型的别名" id="result类型的别名">result类型的别名</a></h1>
<h1><a class="header" href="#打印错误" id="打印错误">打印错误</a></h1>
<h1><a class="header" href="#传递错误" id="传递错误">传递错误</a></h1>
<h1><a class="header" href="#处理多种错误类型" id="处理多种错误类型">处理多种错误类型</a></h1>
<h1><a class="header" href="#处理不能发生的错误" id="处理不能发生的错误">处理“不能发生”的错误</a></h1>
<h1><a class="header" href="#忽略错误" id="忽略错误">忽略错误</a></h1>
<h1><a class="header" href="#处理main中的错误" id="处理main中的错误">处理main()中的错误</a></h1>
<h1><a class="header" href="#声明一个定制的错误类型" id="声明一个定制的错误类型">声明一个定制的错误类型</a></h1>
<h1><a class="header" href="#为什么会有result" id="为什么会有result">为什么会有result？</a></h1>
<h1><a class="header" href="#第八章-crates和模块" id="第八章-crates和模块">第八章 Crates和模块</a></h1>
<h1><a class="header" href="#crates" id="crates">Crates</a></h1>
<h1><a class="header" href="#建立配置文件" id="建立配置文件">建立配置文件</a></h1>
<h1><a class="header" href="#模块" id="模块">模块</a></h1>
<h1><a class="header" href="#在不同文件中的模块" id="在不同文件中的模块">在不同文件中的模块</a></h1>
<h1><a class="header" href="#路径和导入" id="路径和导入">路径和导入</a></h1>
<h1><a class="header" href="#标准预加载库" id="标准预加载库">标准预加载库</a></h1>
<h1><a class="header" href="#构成rust的单元" id="构成rust的单元">构成Rust的单元</a></h1>
<h1><a class="header" href="#将程序变为库" id="将程序变为库">将程序变为库</a></h1>
<h1><a class="header" href="#srcbin目录" id="srcbin目录">src/bin目录</a></h1>
<h1><a class="header" href="#属性" id="属性">属性</a></h1>
<h1><a class="header" href="#测试和文档" id="测试和文档">测试和文档</a></h1>
<h1><a class="header" href="#内部测试" id="内部测试">内部测试</a></h1>
<h1><a class="header" href="#文档" id="文档">文档</a></h1>
<h1><a class="header" href="#文档中的测试" id="文档中的测试">文档中的测试</a></h1>
<h1><a class="header" href="#指定依赖" id="指定依赖">指定依赖</a></h1>
<h1><a class="header" href="#版本" id="版本">版本</a></h1>
<h1><a class="header" href="#cargolock" id="cargolock">Cargo.lock</a></h1>
<h1><a class="header" href="#发布crates至cratesio" id="发布crates至cratesio">发布crates至crates.io</a></h1>
<h1><a class="header" href="#工作空间" id="工作空间">工作空间</a></h1>
<h1><a class="header" href="#其他有趣的事" id="其他有趣的事">其他有趣的事</a></h1>
<h1><a class="header" href="#第九章-结构体" id="第九章-结构体">第九章 结构体</a></h1>
<h1><a class="header" href="#命名字段结构体" id="命名字段结构体">命名字段结构体</a></h1>
<h1><a class="header" href="#类原则结构体" id="类原则结构体">类原则结构体</a></h1>
<h1><a class="header" href="#单位结构体" id="单位结构体">单位结构体</a></h1>
<h1><a class="header" href="#struct的内存布局" id="struct的内存布局">struct的内存布局</a></h1>
<h1><a class="header" href="#用impl定义方法" id="用impl定义方法">用impl定义方法</a></h1>
<h1><a class="header" href="#泛型结构体" id="泛型结构体">泛型结构体</a></h1>
<h1><a class="header" href="#带生命周期参数的结构体" id="带生命周期参数的结构体">带生命周期参数的结构体</a></h1>
<h1><a class="header" href="#为结构体类型派生通用traits" id="为结构体类型派生通用traits">为结构体类型派生通用traits</a></h1>
<h1><a class="header" href="#内在可变性" id="内在可变性">内在可变性</a></h1>
<h1><a class="header" href="#第十章-枚举和模式" id="第十章-枚举和模式">第十章 枚举和模式</a></h1>
<h1><a class="header" href="#枚举" id="枚举">枚举</a></h1>
<h1><a class="header" href="#带有数据的枚举" id="带有数据的枚举">带有数据的枚举</a></h1>
<h1><a class="header" href="#枚举的内存布局" id="枚举的内存布局">枚举的内存布局</a></h1>
<h1><a class="header" href="#在枚举中使用许多的数据结构" id="在枚举中使用许多的数据结构">在枚举中使用许多的数据结构</a></h1>
<h1><a class="header" href="#泛型枚举" id="泛型枚举">泛型枚举</a></h1>
<h1><a class="header" href="#模式" id="模式">模式</a></h1>
<h1><a class="header" href="#模式中的字面量变量和通配符" id="模式中的字面量变量和通配符">模式中的字面量，变量和通配符</a></h1>
<h1><a class="header" href="#元组和结构体模式" id="元组和结构体模式">元组和结构体模式</a></h1>
<h1><a class="header" href="#引用模式" id="引用模式">引用模式</a></h1>
<h1><a class="header" href="#满足许多可能性" id="满足许多可能性">满足许多可能性</a></h1>
<h1><a class="header" href="#模式判断" id="模式判断">模式判断</a></h1>
<h1><a class="header" href="#模式-1" id="模式-1">@模式</a></h1>
<h1><a class="header" href="#哪里可以使用模式" id="哪里可以使用模式">哪里可以使用模式</a></h1>
<h1><a class="header" href="#填充一个二叉树" id="填充一个二叉树">填充一个二叉树</a></h1>
<h1><a class="header" href="#伟大构想" id="伟大构想">伟大构想</a></h1>
<h1><a class="header" href="#第十一章-traits和泛型" id="第十一章-traits和泛型">第十一章 traits和泛型</a></h1>
<h1><a class="header" href="#使用traits" id="使用traits">使用Traits</a></h1>
<h1><a class="header" href="#trait-objects" id="trait-objects">trait objects</a></h1>
<h1><a class="header" href="#trait-object的内存布局" id="trait-object的内存布局">trait object的内存布局</a></h1>
<h1><a class="header" href="#泛型函数" id="泛型函数">泛型函数</a></h1>
<h1><a class="header" href="#用哪一个" id="用哪一个">用哪一个？</a></h1>
<h1><a class="header" href="#定义并实现trait" id="定义并实现trait">定义并实现trait</a></h1>
<h1><a class="header" href="#默认方法" id="默认方法">默认方法</a></h1>
<h1><a class="header" href="#traits和其他人的类型" id="traits和其他人的类型">traits和其他人的类型</a></h1>
<h1><a class="header" href="#traits中的self" id="traits中的self">traits中的self</a></h1>
<h1><a class="header" href="#子trait" id="子trait">子trait</a></h1>
<h1><a class="header" href="#静态方法" id="静态方法">静态方法</a></h1>
<h1><a class="header" href="#完备的方法调用" id="完备的方法调用">完备的方法调用</a></h1>
<h1><a class="header" href="#在类型间定义关系的trait" id="在类型间定义关系的trait">在类型间定义关系的trait</a></h1>
<h1><a class="header" href="#关联类型iterator是怎么运行的" id="关联类型iterator是怎么运行的">关联类型(iterator是怎么运行的)</a></h1>
<h1><a class="header" href="#泛型trait操作符重载的机理" id="泛型trait操作符重载的机理">泛型trait(操作符重载的机理)</a></h1>
<h1><a class="header" href="#密友traitrandrandom是怎么实现的" id="密友traitrandrandom是怎么实现的">密友trait(rand::random()是怎么实现的)</a></h1>
<h1><a class="header" href="#对绑定的逆向工程" id="对绑定的逆向工程">对绑定的逆向工程</a></h1>
<h1><a class="header" href="#总结" id="总结">总结</a></h1>
<h1><a class="header" href="#第十二章-重载操作符" id="第十二章-重载操作符">第十二章 重载操作符</a></h1>
<h1><a class="header" href="#算术和位操作符" id="算术和位操作符">算术和位操作符</a></h1>
<h1><a class="header" href="#一元操作符" id="一元操作符">一元操作符</a></h1>
<h1><a class="header" href="#二元操作符" id="二元操作符">二元操作符</a></h1>
<h1><a class="header" href="#复合赋值操作符" id="复合赋值操作符">复合赋值操作符</a></h1>
<h1><a class="header" href="#相等性测试" id="相等性测试">相等性测试</a></h1>
<h1><a class="header" href="#有序比较" id="有序比较">有序比较</a></h1>
<h1><a class="header" href="#index和indexmut" id="index和indexmut">index和indexMut</a></h1>
<h1><a class="header" href="#其他操作符" id="其他操作符">其他操作符</a></h1>
<h1><a class="header" href="#第十三章-实用traits" id="第十三章-实用traits">第十三章 实用Traits</a></h1>
<h1><a class="header" href="#drop" id="drop">Drop</a></h1>
<h1><a class="header" href="#sized" id="sized">Sized</a></h1>
<h1><a class="header" href="#clone" id="clone">Clone</a></h1>
<h1><a class="header" href="#copy" id="copy">Copy</a></h1>
<h1><a class="header" href="#deref和derefmut" id="deref和derefmut">Deref和derefMut</a></h1>
<h1><a class="header" href="#default" id="default">Default</a></h1>
<h1><a class="header" href="#asref和asmut" id="asref和asmut">AsRef和AsMut</a></h1>
<h1><a class="header" href="#borrow和borrowmut" id="borrow和borrowmut">Borrow和BorrowMut</a></h1>
<h1><a class="header" href="#from和into" id="from和into">From和Into</a></h1>
<h1><a class="header" href="#toowned" id="toowned">ToOwned</a></h1>
<h1><a class="header" href="#使用borrow和toowned卑微的牛" id="使用borrow和toowned卑微的牛">使用Borrow和ToOwned：卑微的牛</a></h1>
<h1><a class="header" href="#第十四章-闭包" id="第十四章-闭包">第十四章 闭包</a></h1>
<h1><a class="header" href="#捕获变量" id="捕获变量">捕获变量</a></h1>
<h1><a class="header" href="#借用的闭包" id="借用的闭包">借用的闭包</a></h1>
<h1><a class="header" href="#偷来的闭包" id="偷来的闭包">偷来的闭包</a></h1>
<h1><a class="header" href="#函数和闭包类型" id="函数和闭包类型">函数和闭包类型</a></h1>
<h1><a class="header" href="#闭包的性能" id="闭包的性能">闭包的性能</a></h1>
<h1><a class="header" href="#闭包的安全性" id="闭包的安全性">闭包的安全性</a></h1>
<h1><a class="header" href="#闭包丢弃的" id="闭包丢弃的">闭包丢弃的...</a></h1>
<h1><a class="header" href="#fnonce" id="fnonce">FnOnce</a></h1>
<h1><a class="header" href="#fnmut" id="fnmut">FnMut</a></h1>
<h1><a class="header" href="#回调" id="回调">回调</a></h1>
<h1><a class="header" href="#有效地使用闭包" id="有效地使用闭包">有效地使用闭包</a></h1>
<h1><a class="header" href="#第十五章-迭代器" id="第十五章-迭代器">第十五章 迭代器</a></h1>
<h1><a class="header" href="#迭代器和其内置traits" id="迭代器和其内置traits">迭代器和其内置Traits</a></h1>
<h1><a class="header" href="#创造迭代器" id="创造迭代器">创造迭代器</a></h1>
<h1><a class="header" href="#iter和iter_mut方法" id="iter和iter_mut方法">iter和iter_mut方法</a></h1>
<h1><a class="header" href="#内置迭代器的实现" id="内置迭代器的实现">内置迭代器的实现</a></h1>
<h1><a class="header" href="#drain方法" id="drain方法">drain方法</a></h1>
<h1><a class="header" href="#其他迭代器的资料" id="其他迭代器的资料">其他迭代器的资料</a></h1>
<h1><a class="header" href="#迭代器的配备" id="迭代器的配备">迭代器的配备</a></h1>
<h1><a class="header" href="#map和filter" id="map和filter">map和filter</a></h1>
<h1><a class="header" href="#filter_map和flat_map" id="filter_map和flat_map">filter_map和flat_map</a></h1>
<h1><a class="header" href="#scan" id="scan">scan</a></h1>
<h1><a class="header" href="#take和take_while" id="take和take_while">take和take_while</a></h1>
<h1><a class="header" href="#skip和skip_while" id="skip和skip_while">skip和skip_while</a></h1>
<h1><a class="header" href="#peekable" id="peekable">peekable</a></h1>
<h1><a class="header" href="#fuse" id="fuse">fuse</a></h1>
<h1><a class="header" href="#可逆的迭代器和rev" id="可逆的迭代器和rev">可逆的迭代器和rev</a></h1>
<h1><a class="header" href="#inspect" id="inspect">inspect</a></h1>
<h1><a class="header" href="#chain" id="chain">chain</a></h1>
<h1><a class="header" href="#enumerate" id="enumerate">enumerate</a></h1>
<h1><a class="header" href="#zip" id="zip">zip</a></h1>
<h1><a class="header" href="#by_ref" id="by_ref">by_ref</a></h1>
<h1><a class="header" href="#cloned" id="cloned">cloned</a></h1>
<h1><a class="header" href="#cycle" id="cycle">cycle</a></h1>
<h1><a class="header" href="#消耗迭代器" id="消耗迭代器">消耗迭代器</a></h1>
<h1><a class="header" href="#简单的累运算计数总和乘积" id="简单的累运算计数总和乘积">简单的累运算:计数，总和，乘积</a></h1>
<h1><a class="header" href="#max-min" id="max-min">max, min</a></h1>
<h1><a class="header" href="#max_by-min_by" id="max_by-min_by">max_by, min_by</a></h1>
<h1><a class="header" href="#max_by_key-min_by_key" id="max_by_key-min_by_key">max_by_key, min_by_key</a></h1>
<h1><a class="header" href="#比较序列" id="比较序列">比较序列</a></h1>
<h1><a class="header" href="#any和all" id="any和all">any和all</a></h1>
<h1><a class="header" href="#position-rposition-和-exactsizeiterator" id="position-rposition-和-exactsizeiterator">position, rposition, 和 ExactSizeIterator</a></h1>
<h1><a class="header" href="#fold" id="fold">fold</a></h1>
<h1><a class="header" href="#nth" id="nth">nth</a></h1>
<h1><a class="header" href="#last" id="last">last</a></h1>
<h1><a class="header" href="#find" id="find">find</a></h1>
<h1><a class="header" href="#构建集合collect和fromiterator" id="构建集合collect和fromiterator">构建集合:collect和FromIterator</a></h1>
<h1><a class="header" href="#trait-extend" id="trait-extend">trait: extend</a></h1>
<h1><a class="header" href="#partition" id="partition">partition</a></h1>
<h1><a class="header" href="#实现你自己的迭代器" id="实现你自己的迭代器">实现你自己的迭代器</a></h1>
<h1><a class="header" href="#第十六章-集合类型" id="第十六章-集合类型">第十六章 集合类型</a></h1>
<h1><a class="header" href="#总览" id="总览">总览</a></h1>
<h1><a class="header" href="#vec" id="vec">Vec</a></h1>
<h1><a class="header" href="#索引元素" id="索引元素">索引元素</a></h1>
<h1><a class="header" href="#迭代" id="迭代">迭代</a></h1>
<h1><a class="header" href="#增长和缩短的向量" id="增长和缩短的向量">增长和缩短的向量</a></h1>
<h1><a class="header" href="#拼接" id="拼接">拼接</a></h1>
<h1><a class="header" href="#分割" id="分割">分割</a></h1>
<h1><a class="header" href="#交换" id="交换">交换</a></h1>
<h1><a class="header" href="#排序和寻找" id="排序和寻找">排序和寻找</a></h1>
<h1><a class="header" href="#比较切片" id="比较切片">比较切片</a></h1>
<h1><a class="header" href="#随机元素" id="随机元素">随机元素</a></h1>
<h1><a class="header" href="#rust排除了无效错误" id="rust排除了无效错误">Rust排除了无效错误</a></h1>
<h1><a class="header" href="#vecdeque" id="vecdeque">VecDeque</a></h1>
<h1><a class="header" href="#linkedlist" id="linkedlist">LinkedList</a></h1>
<h1><a class="header" href="#binaryheap" id="binaryheap">BinaryHeap</a></h1>
<h1><a class="header" href="#hashmapkv和btreemapkv" id="hashmapkv和btreemapkv">HashMap&lt;K,V&gt;和BTreeMap&lt;K,V&gt;</a></h1>
<h1><a class="header" href="#条目" id="条目">条目</a></h1>
<h1><a class="header" href="#映射迭代" id="映射迭代">映射迭代</a></h1>
<h1><a class="header" href="#hashset和btreeset" id="hashset和btreeset">HashSet和BTreeSet</a></h1>
<h1><a class="header" href="#设置迭代" id="设置迭代">设置迭代</a></h1>
<h1><a class="header" href="#当相等的元素不一样时" id="当相等的元素不一样时">当相等的元素不一样时</a></h1>
<h1><a class="header" href="#整体操作" id="整体操作">整体操作</a></h1>
<h1><a class="header" href="#哈希" id="哈希">哈希</a></h1>
<h1><a class="header" href="#使用定制的哈希算法" id="使用定制的哈希算法">使用定制的哈希算法</a></h1>
<h1><a class="header" href="#标准集合之外" id="标准集合之外">标准集合之外</a></h1>
<h1><a class="header" href="#第十七章-字符串和文本" id="第十七章-字符串和文本">第十七章 字符串和文本</a></h1>
<h1><a class="header" href="#一些unicode背景知识" id="一些unicode背景知识">一些Unicode背景知识</a></h1>
<h1><a class="header" href="#asciilatin-1和unicode" id="asciilatin-1和unicode">ASCII，Latin-1和Unicode</a></h1>
<h1><a class="header" href="#utf-8" id="utf-8">UTF-8</a></h1>
<h1><a class="header" href="#定向文本" id="定向文本">定向文本</a></h1>
<h1><a class="header" href="#字符-1" id="字符-1">字符</a></h1>
<h1><a class="header" href="#字符分类" id="字符分类">字符分类</a></h1>
<h1><a class="header" href="#处理数字" id="处理数字">处理数字</a></h1>
<h1><a class="header" href="#字符的大小写转换" id="字符的大小写转换">字符的大小写转换</a></h1>
<h1><a class="header" href="#从整数转换和转换为整数" id="从整数转换和转换为整数">从整数转换和转换为整数</a></h1>
<h1><a class="header" href="#string和str" id="string和str">String和str</a></h1>
<h1><a class="header" href="#创造string的值" id="创造string的值">创造String的值</a></h1>
<h1><a class="header" href="#简单的反射" id="简单的反射">简单的反射</a></h1>
<h1><a class="header" href="#添加或插入文本" id="添加或插入文本">添加或插入文本</a></h1>
<h1><a class="header" href="#删除文本" id="删除文本">删除文本</a></h1>
<h1><a class="header" href="#搜索和迭代的惯例" id="搜索和迭代的惯例">搜索和迭代的惯例</a></h1>
<h1><a class="header" href="#搜索文本的模式" id="搜索文本的模式">搜索文本的模式</a></h1>
<h1><a class="header" href="#查找和替换" id="查找和替换">查找和替换</a></h1>
<h1><a class="header" href="#遍历文本" id="遍历文本">遍历文本</a></h1>
<h1><a class="header" href="#修剪" id="修剪">修剪</a></h1>
<h1><a class="header" href="#字符串的大小转换" id="字符串的大小转换">字符串的大小转换</a></h1>
<h1><a class="header" href="#将string解析为其他类型" id="将string解析为其他类型">将string解析为其他类型</a></h1>
<h1><a class="header" href="#将其他类型转为string" id="将其他类型转为string">将其他类型转为string</a></h1>
<h1><a class="header" href="#像其他类文本一样的类型进行借用" id="像其他类文本一样的类型进行借用">像其他类文本一样的类型进行借用</a></h1>
<h1><a class="header" href="#访问utf-8的文本" id="访问utf-8的文本">访问utf-8的文本</a></h1>
<h1><a class="header" href="#根据utf-8数据提供文本" id="根据utf-8数据提供文本">根据utf-8数据提供文本</a></h1>
<h1><a class="header" href="#推迟分配" id="推迟分配">推迟分配</a></h1>
<h1><a class="header" href="#作为泛型集合的字符串" id="作为泛型集合的字符串">作为泛型集合的字符串</a></h1>
<h1><a class="header" href="#格式化" id="格式化">格式化</a></h1>
<h1><a class="header" href="#格式化文本值" id="格式化文本值">格式化文本值</a></h1>
<h1><a class="header" href="#格式化数字" id="格式化数字">格式化数字</a></h1>
<h1><a class="header" href="#格式化其他类型" id="格式化其他类型">格式化其他类型</a></h1>
<h1><a class="header" href="#调试下的格式化" id="调试下的格式化">调试下的格式化</a></h1>
<h1><a class="header" href="#调试下的指针格式化" id="调试下的指针格式化">调试下的指针格式化</a></h1>
<h1><a class="header" href="#通过索引或名字指向参数" id="通过索引或名字指向参数">通过索引或名字指向参数</a></h1>
<h1><a class="header" href="#动态的宽度和精度" id="动态的宽度和精度">动态的宽度和精度</a></h1>
<h1><a class="header" href="#格式化你自己的类型" id="格式化你自己的类型">格式化你自己的类型</a></h1>
<h1><a class="header" href="#在你自己的代码使用格式化语言" id="在你自己的代码使用格式化语言">在你自己的代码使用格式化语言</a></h1>
<h1><a class="header" href="#正则表达式" id="正则表达式">正则表达式</a></h1>
<h1><a class="header" href="#基础" id="基础">基础</a></h1>
<h1><a class="header" href="#创建惰性正则表达式的值" id="创建惰性正则表达式的值">创建惰性正则表达式的值</a></h1>
<h1><a class="header" href="#标准化" id="标准化">标准化</a></h1>
<h1><a class="header" href="#标准化格式" id="标准化格式">标准化格式</a></h1>
<h1><a class="header" href="#unicode标准化crate" id="unicode标准化crate">Unicode标准化crate</a></h1>
<h1><a class="header" href="#第十八章-输入和输出" id="第十八章-输入和输出">第十八章 输入和输出</a></h1>
<h1><a class="header" href="#读者和作者" id="读者和作者">读者和作者</a></h1>
<h1><a class="header" href="#读者" id="读者">“读者”</a></h1>
<h1><a class="header" href="#缓冲区的读者" id="缓冲区的读者">缓冲区的读者</a></h1>
<h1><a class="header" href="#写入行" id="写入行">写入行</a></h1>
<h1><a class="header" href="#收集行" id="收集行">收集行</a></h1>
<h1><a class="header" href="#作者-1" id="作者-1">“作者”</a></h1>
<h1><a class="header" href="#文件" id="文件">文件</a></h1>
<h1><a class="header" href="#寻找" id="寻找">寻找</a></h1>
<h1><a class="header" href="#其他读者和作者类型" id="其他读者和作者类型">其他读者和作者类型</a></h1>
<h1><a class="header" href="#二进制数据的压缩和序列化" id="二进制数据的压缩和序列化">二进制数据的压缩和序列化</a></h1>
<h1><a class="header" href="#文件和目录" id="文件和目录">文件和目录</a></h1>
<h1><a class="header" href="#osstr和path" id="osstr和path">OsStr和Path</a></h1>
<h1><a class="header" href="#path和pathbuf方法" id="path和pathbuf方法">Path和PathBuf方法</a></h1>
<h1><a class="header" href="#文件系统访问函数" id="文件系统访问函数">文件系统访问函数</a></h1>
<h1><a class="header" href="#读取目录" id="读取目录">读取目录</a></h1>
<h1><a class="header" href="#特定平台的特性" id="特定平台的特性">特定平台的特性</a></h1>
<h1><a class="header" href="#网络" id="网络">网络</a></h1>
<h1><a class="header" href="#第十九章-并发" id="第十九章-并发">第十九章 并发</a></h1>
<h1><a class="header" href="#fork-join-并行性" id="fork-join-并行性">Fork-Join 并行性</a></h1>
<h1><a class="header" href="#生产" id="生产">生产</a></h1>
<h1><a class="header" href="#跨线程的错误处理" id="跨线程的错误处理">跨线程的错误处理</a></h1>
<h1><a class="header" href="#跨线程分享不可变数据" id="跨线程分享不可变数据">跨线程分享不可变数据</a></h1>
<h1><a class="header" href="#rayon" id="rayon">rayon</a></h1>
<h1><a class="header" href="#再看曼德勃罗集合" id="再看曼德勃罗集合">再看曼德勃罗集合</a></h1>
<h1><a class="header" href="#通道" id="通道">通道</a></h1>
<h1><a class="header" href="#发送值" id="发送值">发送值</a></h1>
<h1><a class="header" href="#接收值" id="接收值">接收值</a></h1>
<h1><a class="header" href="#运行管道" id="运行管道">运行管道</a></h1>
<h1><a class="header" href="#通道的特性和性能" id="通道的特性和性能">通道的特性和性能</a></h1>
<h1><a class="header" href="#线程安全性发送和同步" id="线程安全性发送和同步">线程安全性：发送和同步</a></h1>
<h1><a class="header" href="#将几乎所有迭代器管道化为一个通道" id="将几乎所有迭代器管道化为一个通道">将几乎所有迭代器管道化为一个通道</a></h1>
<h1><a class="header" href="#管道之外" id="管道之外">管道之外</a></h1>
<h1><a class="header" href="#分享可变状态" id="分享可变状态">分享可变状态</a></h1>
<h1><a class="header" href="#什么是mutex" id="什么是mutex">什么是mutex</a></h1>
<h1><a class="header" href="#mutex" id="mutex">Mutex</a></h1>
<h1><a class="header" href="#mut和mutex" id="mut和mutex">mut和Mutex</a></h1>
<h1><a class="header" href="#为什么mutexes并不总是一个好想法" id="为什么mutexes并不总是一个好想法">为什么Mutexes并不总是一个好想法</a></h1>
<h1><a class="header" href="#死锁" id="死锁">死锁</a></h1>
<h1><a class="header" href="#有毒的mutexes" id="有毒的mutexes">有毒的Mutexes</a></h1>
<h1><a class="header" href="#多个生产者通道使用mutexes" id="多个生产者通道使用mutexes">多个生产者通道使用mutexes</a></h1>
<h1><a class="header" href="#读或写锁rwlock" id="读或写锁rwlock">读或写锁(RwLock)</a></h1>
<h1><a class="header" href="#特定变量condvar" id="特定变量condvar">特定变量(Condvar)</a></h1>
<h1><a class="header" href="#原子性" id="原子性">原子性</a></h1>
<h1><a class="header" href="#全局变量" id="全局变量">全局变量</a></h1>
<h1><a class="header" href="#在rust中编写并发代码" id="在rust中编写并发代码">在rust中编写并发代码...</a></h1>
<h1><a class="header" href="#第二十章-宏" id="第二十章-宏">第二十章 宏</a></h1>
<h1><a class="header" href="#基本的宏" id="基本的宏">基本的宏</a></h1>
<h1><a class="header" href="#宏扩展的基础" id="宏扩展的基础">宏扩展的基础</a></h1>
<h1><a class="header" href="#意想不到的影响" id="意想不到的影响">意想不到的影响</a></h1>
<h1><a class="header" href="#重复" id="重复">重复</a></h1>
<h1><a class="header" href="#内置宏" id="内置宏">内置宏</a></h1>
<h1><a class="header" href="#调试宏" id="调试宏">调试宏</a></h1>
<h1><a class="header" href="#json宏" id="json宏">json!宏</a></h1>
<h1><a class="header" href="#破碎的类型" id="破碎的类型">破碎的类型</a></h1>
<h1><a class="header" href="#宏中的递归" id="宏中的递归">宏中的递归</a></h1>
<h1><a class="header" href="#与宏一起使用traits" id="与宏一起使用traits">与宏一起使用traits</a></h1>
<h1><a class="header" href="#作用域的纯净" id="作用域的纯净">作用域的纯净</a></h1>
<h1><a class="header" href="#导入和导出宏" id="导入和导出宏">导入和导出宏</a></h1>
<h1><a class="header" href="#匹配时避免语法错误" id="匹配时避免语法错误">匹配时避免语法错误</a></h1>
<h1><a class="header" href="#宏规则之外" id="宏规则之外">宏规则之外</a></h1>
<h1><a class="header" href="#第二十一章-不安全的代码" id="第二十一章-不安全的代码">第二十一章 “不安全的”代码</a></h1>
<h1><a class="header" href="#不安全的来源" id="不安全的来源">不安全的来源？</a></h1>
<h1><a class="header" href="#不安全块" id="不安全块">不安全块</a></h1>
<h1><a class="header" href="#例子一个有效的ascii字符串类型" id="例子一个有效的ascii字符串类型">例子：一个有效的ASCII字符串类型</a></h1>
<h1><a class="header" href="#不安全的函数" id="不安全的函数">不安全的函数</a></h1>
<h1><a class="header" href="#不安全的块或不安全的函数" id="不安全的块或不安全的函数">不安全的块或不安全的函数？</a></h1>
<h1><a class="header" href="#未定义的行为" id="未定义的行为">未定义的行为</a></h1>
<h1><a class="header" href="#不安全的trait" id="不安全的trait">不安全的trait</a></h1>
<h1><a class="header" href="#原生指针-1" id="原生指针-1">原生指针</a></h1>
<h1><a class="header" href="#安全的解引用原生指针" id="安全的解引用原生指针">安全的解引用原生指针</a></h1>
<h1><a class="header" href="#例子refwithflag" id="例子refwithflag">例子：RefWithFlag</a></h1>
<h1><a class="header" href="#可为空的指针" id="可为空的指针">可为空的指针</a></h1>
<h1><a class="header" href="#类型大小和比对" id="类型大小和比对">类型大小和比对</a></h1>
<h1><a class="header" href="#算术指针" id="算术指针">算术指针</a></h1>
<h1><a class="header" href="#移进或移出内存" id="移进或移出内存">移进或移出内存</a></h1>
<h1><a class="header" href="#例子gapbuffer" id="例子gapbuffer">例子：gapBuffer</a></h1>
<h1><a class="header" href="#不安全的代码中安全的panic" id="不安全的代码中安全的panic">不安全的代码中安全的panic</a></h1>
<h1><a class="header" href="#外部函数从rust中调用c和c" id="外部函数从rust中调用c和c">外部函数：从Rust中调用C和C++</a></h1>
<h1><a class="header" href="#寻找通用的数据呈现" id="寻找通用的数据呈现">寻找通用的数据呈现</a></h1>
<h1><a class="header" href="#声明外部函数和变量" id="声明外部函数和变量">声明外部函数和变量</a></h1>
<h1><a class="header" href="#从库中使用函数" id="从库中使用函数">从库中使用函数</a></h1>
<h1><a class="header" href="#libgit2中的一个原生接口" id="libgit2中的一个原生接口">libgit2中的一个原生接口</a></h1>
<h1><a class="header" href="#libgit2中的一个安全接口" id="libgit2中的一个安全接口">libgit2中的一个安全接口</a></h1>
<h1><a class="header" href="#总结-1" id="总结-1">总结</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
